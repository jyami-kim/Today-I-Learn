# 3. 애그리거트

### 애그리거트

- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들기 위해 상위수준에서 모델을 조망할 수 있는 방법이 필요.
- 관련된 객체를 하나의 군으로 묶어준다.

- 모델을 이해하는데 도움을 주고 일관성을 관리하는 기준이 된다.
- 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다
- 경계를 설정할 때 기본이 되는 것 == 도메인 규칙과 요구사항 (함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높다)
- A가 B를 갖는다 (has 관계)일때 반드시 한 애그리거트에 속하는 것은 아니다.



### 애그리거트 루트

- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한다. 이 책임을 지는 것이 애그리커트 루트 엔티티다
- 애그리거트의 대표 엔티티
- 애그리거트에 속한 객체 == 애그리거트 루트 엔티티에 직 간접적으로 속함
- 애그리거트의 일관성이 깨지지 않는 것



### 도메인 규칙과 일관성

- 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현함
- 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않게 구현한다.
- 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다.



도메인 모델에 대해 가져야할 습관

- 단순이 필드를 변경하는 set메서드를 공개(public)로 만들지 않는다

  > set 메서드는 비즈니스를 표현하지 않는다.

- 밸류 타입은 불변으로 구현한다.

  > 불변이라 외부에서 내부 상태를 함부로 바꾸지 못해 애그리거트 일관성이 깨질 가능성이 줄어든다.



### 애그리거트 루트의 기능 구현

애그리거트 루트 : 애그리거트 내부의 다른 객체를 조합해서 기능을 완성함

한 애그리거트에 속하는 모델은 한 패키지에 속함 

> 패키지나 protected 범위를 사용해 애그리거트 외부에서 상태 변경 기능을 실행하지 않게 방지한다.



### 트랜잭션 범위

한 트랜잭션에서는 한개의 애그리거트만 수정해야한다.

한 트랜잭션에서 한 애그리거트만 수정한다 => 애그리거트에서 다른 애그리거트를 변경하지 않는다.

한개 트랜잭션에서 두개 이상의 애거리거트를 변경할때

- 팀 표준: 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야하는 경우
- 기술 제약 : 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트 수정하여 일관성 처리
- UI 구현의 편리: 운영자의 편리함을 위해

도메인 이벤트 : 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드 작성 가능



### 리포지터리와 애그리거트

애그리거트는 개념상 한개의 한개의 도메인 모델을 표현함.  > 객체의 영속성을 처리하는 리포지터리도 애그리거트 단위로 존재

Order가 애글리거트 루트이면 Order를 위한 리포지터리만 존재함

애그리거트를 영속화할 저장소로 무엇을 상태하든, 애그리거트 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 함

같은 애그리거트는 같은 생명주기를 가지므로, 그 같은 생명주기를 같이 변경하는 리포지터리가 1개임



### ID를 이용한 애그리거트 참조

애그리거트에서 다른 애그리거트를 참조한다 == 애그리거트의 루트를 참조한다

애그리거트 간 참조는 *필드*를 통해 쉽게 구현이 가능하다. (@OneToOne, @ManyToOne 등 사용)

- 편한 탐색 오용 : 가장 큰 문제

  한 애그리거트에서 다른 애그리거트의 상태를 변경하려하는 유혹에 빠지기 쉽다 (의존 결합도가 높여짐)

- 성능에 대한 고민

  지연로딩, 즉시로딩 두가지 방식으로 로딩. (어떤 기능을 사용할지에 따라 달라짐)

- 확장 어려움

  사용자가 늘고 트래픽이 증가하면 부하 분산을 위해 도메인 별로 시스템을 분리하기 시작함. 
  하위 도메인 마다 서로 다른 DBMS를 사용할 가능성이 높아진다. (JPA 같은 단일 기술을 사용할 수 없음)

해결방법 > ID를 이용한 간접 참조 (외래키 참조와 비슷)

- 모든 객체가 참조로 연결되지 않고, 한 애그리거트에 속한 객체들만 참조로 연결된다 (모델 복잡도를 낮춰줌)
- 한 애그리거트에서 다른 애그리 거트를 수정하는 문제를 원천적으로 방지
- 애그리거트 별로 다른 구현 기술을 사용하는 것도 가능해짐



### ID를 이용한 참조와 조회 성능

참조하는 여러 애그리거트를 읽어야 할 때 조회 속도가 문제될 수 있다.

N+1 조회문제 : 전체 조회 속도가 느려지는 원인

- 해결 > 전용 조회커리를 만들어서 사용한다. 

애그리거트마다 서로 다른 저장소를 사용하면?

- 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성함



### 애그리거트 간 집합 연관

애그리거트간 1:N 관계 : Set 컬렉션

그런데 개념적으로 존재하는 애그리거트 간의 1:N 연관을 실제 구현에 반영하는 것이 요구사항을 충족하는 것과 상관없는 경우가 종종있다. (페이징을 이용해 제품을 보여줄 때)



M:N 연관 - 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다.

JPA에서는 매핑 설정을 이용해서 사용 가능



### 애그리거트를 팩토리로 사용하기

Store 애그리거트 : 이걸 생성을 하는 팩토리 역할을 하게한다. (팩토리 역할과 중요한 도메인 로직 구현)

장점 : 생성 가능여부를 확인하는 도메인 로직을 변경해도, 도메인 영역의 Store만 변경하면 된다.

애그리거트가 갖고있는 데이터를 이용해서 다른 애그리거트를 생성해야한다면 애그리거트에 팩토리 메서드를 구현하는걸 고려해보자.
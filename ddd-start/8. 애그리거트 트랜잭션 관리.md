# Chapter8. 애그리거트 트랜잭션 관리

### 애그리거트와 트랜잭션

한 애그리거트를 두 사용자가 거의 동시에 변경할 때 트랜잭션이 필요하다.

이때 각각의 트랜잭션에서 잘못되면 애그리거트의 일관성이 깨질 수 있다.

- Pessimisitic Lock : 비관적 잠금 - 선점 잠금
- Optimistic Lock : 낙관적 잠금 - 비선점 잠금



JPA에서는  PESSIMISTIC_WRITE를 전달하면 선점 잠금 방식을 적용할 수 있다.

- 선점 잠금 : 잠금 된 동안 다른 쓰레드의 애그리거트 변경을 블로킹한다.



### 선점 잠금과 교착 상태

교착 상태(deadlock)이 발생하지 않게 주의해야한다.

사용할 때 최대 대기시간을 지정을 꼭 해주어야한다.

1. 스레드1: A 애그리거트에 대한 선점 잠금 구함
2. 스레드2 : B 애그리거트에 대한 선점 잠금 구함
3. 스레드1 : B 애그리거트에 대한 선점 잠금 시도
4. 스레드2 : A 애그리거트에 대한 선점 잠금 시도

DBMS에 따라 교착 상태에 빠진 커넥션을 처리하는 방식이 다르다. 꼭 확인하자



### 비선점 잠금

잠금을 해서 동시에 접근하는 것을 막는 대신, 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식

version update 방식으로 데이터를 수정한다. (애그리거트 버전)

@Version 어노테이션 하나면 JPA에서 버전 상태가 일치하는 경우에만 데이터를 수정한다.

```sql
UPDATE purchase_order SET ... version = version + 1
WHERE number = ? and version = 10
```

트랜잭션 충돌이 발생하면 OptimisticLockingFailureException 발생

애그리거트 정보를 보여줄 때 뷰 코드도 버전 값을 함께 전송해야한다.



비선점 잠금 관련 익센셥

- 스프링 프레임워크 : OptimisticLockingFailureException - 이미 누군가가 애그리거트를 수정했다
- 응용 서비스 코드 : VersionConflictException - 누군가가 거의 동시에 애그리거트를 수정했다.



### 강제 버전 증가

루트 엔티티의 값이 바뀌지 않아도, 애그리거트의 구성요소 중 일부 값이 바뀌면 논리적으로 그 애그리거트는 바뀐 것이다. 

JPA : LockModeType.OPTIMISTIC_FORCE_INCREMENT 를 이용 > 해당 엔티티의 상태 변경 여부에 상관없이 트랜잭션 종료 시점에 버전 값 증가 처리를 한다.



### 오프라인 선점 잠금

여러 트랜잭션에 걸쳐 동시 변경을 막는다.

첫번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제한다. 잠금 해제 전까지 다른 사용자는 잠금을 구할 수 없다.



#### LockManager 인터페이스

기능

- 잠금 선점 시도
- 잠금 확인
- 잠금 해제
- 락 유효시간 연장



접근 제어 과정

1. 오프라인 선점 잠금 시도
2. 기능 실행
3. 잠금 해제에 사용할 LockId를 모델에 추가


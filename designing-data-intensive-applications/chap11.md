# 11. 스트림 처리

### 이벤트 스트림 전송

이벤트 = 스트림 처리 문맥에서의 레코드 : 일반적으로 일기준 시계를 따르는 이벤트 발생 타임스탬프를 포함한다

스트림

- 생산자(producer) = 발행자(publisher), 발송자(sender)
- 소비자(consumer) = 구독자(subscriber) , 수신자(recipient)



### 메시징 시스템

메시징 시스템(messaging system) : 새로운 이벤트에 대해 소비자에게 알려주려고 쓰이는 방법

발행/구독(publicsh/subscribe) 모델

- 생산자가 소비자가 메시지를 처리하는 속도보다 빠르게 메시지를 전송한다면
  - 메시지를 버리거나
  - 큐에 메시지 버퍼링 = 배압(backpressure, 흐름제어(flow control))
  - 생산자가 메시지를 더 보내지 못하게 막는다.
- 노드가 죽거나 일시적으로 오프라인이된다면? 손실되는 메시지가 있을까?

메시지 유실 허용여부는 애플리케이션에 따라 상당히 다르다.



#### 메시지 브로커

메시지 브로커 : 메시지 스트림을 처리하는데 최적화된 데이터베이스 / 서버로 구동되고, 생산자와 소비자는 서버의 클라이언트로 접속한다.

- 생산자는 브로커로 메시지를 전송함
- 소비자는 브로커에서 메시지를 읽어 전송받는다.



#### 메시지 브로커와 데이터베이스의 비교

- 데이터 : 데이터가 삭제될 때까지 보관 / 메시지 브로커 : 소비자에게 배달이 성공하면 자동으로 삭제
- 메시지 브로커 : 대부분 메시지를 지우기 때문에 작업 집합이 작다.
- 데이터베이스 : 보조색인을 지원, 데이터 검색 방법을 다양하게 제공 / 메시지 브로커 : 특정 패턴과 부합하는 토픽의 부분집합을 구독하는 방식



#### 복수 소비자

- 로드밸런싱 : 각 메시지는 소비자 중 하나로 전달된다. : 여러 소비자가 하나의 토픽을 소비하는 작업을 공유
- 팬아웃 : 각 메시지는 모든 소비자에게 전달된다. : 각 메시지를 복수 개의 소비자로 전달



#### 확인 응답과 재전송

소비자는 언제든 장애 발생이 가능하다 (소비자에게 전달했으나, 소비자가 메시지를 처리하지 못하거나, 부분적으로 처리 후 장애가 나는 경우) : **확인 응답(ack)** 으로 메시지 유실이 없게 처리할 수 있다.

재전송행위 : 메시지 순서에 영향을 미친다.

메시지 브로커는 메시지 순서를 유지하려 노력할지라도 **부하 균형 분산**과 **메시지 재전송**을 조합하면 필연적으로 메시지 순서가 변경된다. > 메시지간 인과성이 있다면?



#### 파티셔닝된 로그

브로커는 일시적으로 보관하는 개념으로 만들어졌다.

로그 기반 메시지 브로커**(log-based message broker)** : 데이터베이스의 지속성 있는 저장방법과 메시징 시스템의 지연시간이 짧은 알림 기능을 조합할 수 없을가?



#### 로그를 사용한 메시지 저장소

브로커 구현 (tail -f)

- 생산자 : 보낸 메시지는 로그 끝에 추가
- 소비자 : 로그를 순차적으로 읽어 메시지를 받는다.  > 소비자가 로그 끝에 도달하면 추가됐다는 알림을 기다린다.

오프셋 : 각 파티션 내의 브로커는 모든 메시지에 단조 증가하는 순번을 부여한다.

다른 파티션간의 메시지 순서는 보장 할 수 없다.



#### 로그 방식과 전통적인 메시징 방식의 비교

로그 기반 접근법 : 팬 아웃 메시징 방식을 제공한다

- 소비자가 서로 영향 없이 독립적으로 로그를 읽을 수 있고, 읽어도 로그에서 삭제되지 않기 때문이다.

로드 밸런싱 방법 불리한 면

- 토픽 하나를 소비하는 작업을 공유하는 노드 수는 많아야 해당 토픽의 로그 파티션 수로 제한된다.
- 특정 메시지 처리가 느리면 파티션 내 후속 메시지 처리가 지연된다.



- JMS/AMQP 방식 메시지 브로커 : 메시지 처리 비용이 비싸고 메시지 단위로 병렬화 처리하고 싶지만 메시지 순서는 그렇게 중요하지 않음
- 로그기반 접근법 : 처리량이 많고 메시지를 처리하는 속도가 빠르지만 메시지 순서가 중요하다면 로그 기반 접근법이 효과적이다



#### 소비자 오프셋

소비자 노드에 장애가 바랭하면 : 마지막 기록된 오프셋부터 메시지를 처리하기 시작한다.

장애가 발생한 소비자가 처리했지만 아직 오프셋을 기록하지 못한경우라면? : 메시지가 재시작 할 때 **두 번 처리**된다.



#### 디스크 공간 사용

로그를 계속 추가한다면 결국 디스크 공간을 전부 사용하게 된다. 디스크 공간 재사용을 위해 로그를 여러 조각으로 나누고 조각을 삭제하거나 보관 저장소로 이동하게한다.

메시지 소실 : 로그의 크기는 제한된 버퍼로 구현하고, 버퍼가 가득차면 오래된 메시지 순서대로 버린다 (원형 버퍼, 링 버퍼)



#### 소비자가 생산자를 따라갈 수 없을 때

어떤 소비자가 너무 뒤처져서 메시지를 잃기 시작해도 해당 소비자만 영향을 받고 다른 소비자들의 서비스를 망치지는 않는다. (운영상 장점)



#### 오래된 메시지 재생

로그 기반 메시지 브로커 : 파일을 읽는 작업과 더 유사함 (로그를 변화시키지 않는 읽기 전용 연산) > 오프셋을 늘리는 방식임



### 데이터 베이스와 스트림

이벤트 = 특정 시점에 발생한 사건을 기록한 레코드

사건 = 사용자 활동이나 측정 판독일 수도 있으나 데이터베이스에 기록하는 것일 수도 있다.



#### 시스템 동기화 유지하기

주기적으로 데이터베이스 전체를 덤프하는 작업이 너무 느리면 : 이중기록(dual wirte)이 있다.




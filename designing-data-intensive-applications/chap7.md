# 7. 트랜잭션

트랜잭션 : 애플리케이션에서 몇개의 일기와 쓰기를 하나의 논리적 단위로 묶는 방법이다. 성공(커밋) 또는 실패(어보트(abort), 롤백)

- 데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화 하려는 목적
- 안정성 보장 (safety gurantee) : 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있음



### 1. 애매모호한 트랜잭션의 개념

#### ACID의 의미

원자성(Atomicicty). 일관성(Consistency), 격리성(Isolation), 지속성(Durability)

ACID 표준을 따르지 않은 시스템 : BASE : 기본적으로 가용성을 제공하고 (Basically Available), 유연한 상태를 가지며(Soft state), 최종적 일관성(Eventual consistency)



#### 원자성

시스템은 연산을 실행하기 전이나 실행한 후의 상태에만 있을 수 있으며 그 중간 상태에는 머물 수 없다.

어보트 능력(abortability) : 여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있는데 결함 때문에 완료(커밋) 될 수 없다면 어보트되고 데이터베이스는 이 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소해야한다.



#### 일관성

일관성의 아이디어 : 항상 진실이어야 하는, 데이터에 관한 어떤 선언(불변식(invariant))이 있다

일관성은 애플리케이션의 불변식 개념에 의존한다.



#### 격리성

아무 문제가 없지만 동일한 데이터베이스 레코드에 접근하면 동시성 문제(경쟁 조건)에 맞닥뜨리게 된다.

동시에 실행되는 트랜잭션은 서로 격리된다. 트랜잭셕은 다른 트랜잭션을 방해할 수 없다.

여러 트랜잭션이 동시에 실행되었더라도, 트랜잭션이 순차적으로 실행됐을때 결과와 동일하도록 보장한다.



#### 지속성

지속성은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽어도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장.

복제 기능이 있는 데이터베이스 : 데이터가 성공적으로 다른 노드 몇 개에 복사되었다.



#### 단일 객체 연산과 다중 객체 연산

**다중 객체 트랜잭션** : 데이터의 여러 조각이 동기화된 상태로 유지되어야 할 때 필요하다.

더티 읽기(dirty read) : 격리성 위반 - 트랜잭션이 다른 트랜잭션에서 썼지만, 커밋되지 않은 데이터를 읽음

다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야한다.



#### 단일객체 쓰기

단일 객체 수준에서의 원자성과 격리성을 제공하는 것을 목표로한다.

- 원자성 : 장애 복구(crash recovery)용 로그를 써서 구현
- 격리성 : 각 객체에 잠금을 사용해(동시에 한 스레드만 객체에 접근하도록 구현)

단일 객체 연산 : 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실(lost update)을 방지하므로 유용하다.



#### 다중 객체 트랜잭션의 수준

다중 객체 트랜잭션 지원 포기: 여러 파티션에 걸쳐서 구현하기가 어렵고 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오가 있기 때문



#### 오류와 어보트 처리

트랜잭션 : 오류가 생기면 어보트되고 안전하게 재시도 할 수 있다.

오류 복구는 애플리케이션에게 책임이 있다.



### 완화된 격리 수준

동시성 문제(경쟁조건) : 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때만 나타난다.

직렬성 격리 : 데이터베이스가 여러 트랜잭션들이 직렬적으로 실행되는 것 : 동시성 없이 한 번에 트랜잭션 하나만 실행 > 비용이 있다 > 그냥 완화된 격리 수준을 사용한다 (버그를 유발할 수 있음에도)

맹목적 도구 의존보다는 존재하는 동시성 문제의 종류를 잘 이해하고 방지하는 방법을 배울 필요가 있다.



#### 커밋 후 읽기

커밋 후 읽기(read commited) 

- 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다 (더티 읽기가 없음)
- 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다 (더티 쓰기가 없음)



#### 더티 읽기 방지

유용한 이유

- 트랜잭션이 여러 객체를 갱신하는데, 더티 읽기가 생기면 다른 트랜잭션이 일부는 갱신된 값을, 일부는 갱신되지 않는 값을 볼 수 있다. 부분적 갱신상태의 DB를 보는건 사용자는 혼란스럽다.
- 트랜잭션이 어보트 되면 그때까지 쓴데이터는 모두 롤백되어야하는데, 더티읽기 허용시에는 더 혼란스럽다.



#### 더티 쓰기 방지

더티쓰기(dirty write) : 먼저 쓴내용이 아직 커밋되지 않은 트랜잭션에서 쓴것이고, 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리는 경우



#### 커밋 후 읽기 구현

데이터베이스는 로우 수준 잠금을 사용해 더티 쓰기를 방지한다.

트랜잭션으로 변경을 원하면, 객체에 대한 잠금을 획득해야한다.

운용성을 위해 더티 읽기시 락을 사용하는 방법보다는, 트랜잭션이 실행중인 동안 그 객체를 읽는 다른 트랜잭션은 과거의 값을 읽도록 한다.



#### 스냅숏 격리와 반복 읽기

동시성 버그가 생길 수 있다. 

**비반복 읽기(nonrepeatable read), 읽기 스큐(read skew)** : 한 트랜잭션 내에서 읽은 값이 다르다

**스냅숏 격리** : 가장 흔한 해결책 : 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다 > 백업이나 분석처럼 실행하는 데 오래걸리며 읽기만 실행하는 질의에 요긴하다.



#### 스냅숏 격리 구현

읽기 격리처럼 더티쓰기 방지를 위해 쓰기 잠금을 사용한다.

커밋 후 읽기 격리처럼 전형적으로 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용한다.

스냅숏 격리의 핵심 원리 : 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는 것

**다중 버전 동시성 제어 (multi-version concurrency control, MVCC)**  : 데이터베이스는 객체마다 커밋된 버전 여러개를 유지할 수 있어야한다.

데이터베이스가 커밋 후 읽기 격리만 제공할 필요가 있다면 : 객체마다 버전 두개씩만 유지하면 충분하다. 그러나 읽기 격리를 위해서라도 여러 버전을 사용한 스냅숏을 사용한다.

트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 ID를 할당받는다.



#### 일관된 스냅숏을 보는 가시성 규칙

트랜잭션은 데이터베이스에서 객체를 읽을 때 트랜잭션 ID를 사용해 어떤 것을 볼 수 있고 어떤 것을 볼 수 없는지 결정한다.

객체를 볼 수 있는 시점

- 읽기를 실행하는 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태였다.
- 읽기 대상 객체가 삭제된 것으로 표시되지 않았다. 또는 삭제된 것으로 표시됐지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않았다.



### 직렬성

#### 색인 범위 잠금 

색인 범위 잠금 (Index-range locking, 다음 키 잠금(next-key locking)): 서술 잠금을 근사한 것

오버헤드가 훨씬 더 낫기 때문에 좋은 타협안이 된다.

범위 잠금을 잡을 수 있는 적합한 색인이 없으면, 데이터베이스 테이블 전체에 공유 잠금을 잡는 것으로 대체할 수 있다. (성능엔 나쁘지만 안전한 대비책)



#### 직렬성 스냅숏 격리(SSI)

직렬성 스냅숏 격리 (serializable snapshot isolation, SSI)



#### 비관적 동시성 제어 대 낙관적 동시성 제어

**비관적** 동시성 제어 매커니즘 (2단계 잠금) : (다른 트랜잭션이 획득한 잠금으로 표시되는) 뭔가 잘못 될 가능성이 있으면 뭔가를 하기 전에 상황이 다시 안전해질 때까지 기다리는 게 낫다.

다중 스레드 프로그래밍에서 자료구조 보호를 위해 사용되는 상호 배제(mutual exclusion)과 비슷하다.

**낙관적** 동시성 제어 매커니즘 (직렬성 스냅숏 격리) : 뭔가 위험한 상황이 발생할 가능성이 있을 때 트랜잭션을 막는 대신 모든 것이 괜찮아 질거라는 희망을 갖고 계속 진행한다는것 

- 트랜잭션이 커밋되기를 원할 때 데이터베이스는 나쁜 상황이 발생했는지 확인한다.



#### 뒤처진 전제에 기반한 결정

스냅숏 격리하에서는 트랜잭션이 커밋되는 시점에 원래 질의의 결과과 더 이상 최신이 아닐 수 있다. > 도중에 데이터 변경가능성이 있어서

안전하려면 데이터베이스는 질의 결과(전제)에 변화가 있으면 트랜잭션에서 실행하는 쓰기가 유효하지 않을 수 있다고 가정해야한다.

- 질의결과가 바뀌었는지 알 수 있는 방법 : 오래된 MVCC 객체 버전을 읽었는지 감지하기 - 읽기 전에 커밋되지 않은 쓰기가 발생했음
- 과거의 읽기에 영향을 미치는 쓰기 감지하기 - 읽은 후에 쓰기가 실행됨

직렬성 격리를 제공하려면 : 데이터베이스는 트랜잭션이 뒤처진 전제를 기반으로 동작하는 상황을 감지하고, 이 경우에는 트랜잭션을 어보트해야한다.



##### 1. 오래된 MVCC 읽기 감지하기

트랜잭션이 MVCC 데이터베이스의 일관된 스냅숏에서 읽으면 스냅숏 생성 시점에 다른 트랜잭션이 썼지만 아직 커밋되지 않은 데이터는 무시한다.

트랜잭션이 커밋하려고할 때 데이터베이스는 무시된 쓰기중에 커밋된게 있는지 확인해야한다. 커밋된게 있다면 트랜잭션은 어보트 해야한다.

SSI는 불필요한 어보트를 피해서, 일관된 스냅숏에서 읽으며 오래 실행되는 작업을 지원하는 스냅숏 격리의 특성을 유지한다.



##### 2. 과거의 읽기에 영향을 미치는 쓰기 감지하기

색인 범위 잠금과 비슷하게 SSI 잠금은 다른 트랜잭션을 차단하지 않는것만을 제외하고 비슷한 기법을 사용한다.

트랜잭션이 데이터베이스에 쓸 때 영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 색인에서 확인한다. (색인에 대한 색인 범위 잠금을 이용하여)

트랜잭션이 읽은 데이터가 더 이상 최신이 아니라고 트랜잭션에게 알려줄 뿐이다.



#### 직렬성 스냅숏 격리의 성능

데이터베이스가 각 트랜잭션의 동작을 매우 상세하게 추적하면 어보트돼야하는 트랜잭션을 정확히 판별할 수 있지만, 기록 오버헤드가 심해질 수 있다.

덜 상세하게 추적하면 빠르지만 진짜 필요한 것보다 지나치게 많은 트랜잭션이 어보트될 수 있다.

2단계 잠금과 비교

- 트랜잭션이 다른 트랜잭션들이 잡고있는 잠금을 기다리느라 차단될 필요가 없다. > 지연시간 계측이 쉽고, 변동이 적게 만든다 / 읽기 작업부하가 심한경우에 좋다.

순차 실행과 비교

- 단일 CPU 코어 처리량에 제한되지 않는다. 파운데이션 DB는 직렬성 충돌 감지를 여러 장비로 분산시켜서 처리량이 아주 높도록 확장할 수 있게 한다.
- 여러장비로 파티셔닝 되어도 직렬성 격리를 보장하면서 여러 파티션으로 읽고 쓸 수 있다.

어보트 비율 : SSI 전체적 성능에 큰 영향을 미친다. 
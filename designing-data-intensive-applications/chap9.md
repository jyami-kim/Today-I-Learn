# 9. 일관성과 합의



### 분산 트랜잭션과 합의

여러 노드들이 뭔가에 동의하게 만드는 것

노드가 동의하는 것이 중요한 사항

- 리더 선출
- 원자적 커밋 : 모두 어보트/롤백 되거나 모두 커밋되는 합의 문제



#### 합의 불가능성

죽을 위험이 있는데 신뢰성 있는 합의는 불가능하다 > 그럼에도 합의 알고리즘을 살펴본다



#### 원자적 커밋과 2단계 커밋(2PC)

원자성의 목적 : 트랜잭션의 결과는 커밋 성공이나 어보트

실패한 트랜잭션이 절반만 되어서 일관성이 깨진 데이터베이스의 어지러운 상태를 막아준다.

보조색인이 주 데이터와 일관성을 유지하도록 보장한다.



#### 단일 노드에서 분산 원자적 커밋

단일 데이터베이스 노드에서 실행되는 트랜잭션에게 원자성은 흔히 저장소 엔진에서 구현된다.

단일 노드에서 트랜잭션 커밋은 순서에 결정적으로 의존한다. 트랜잭션이 커밋되거나 어보트되는 시점 : 디스크가 커밋 레코드 쓰기를 마치는 시

여러 노드가 관여할 때 : 다중 객체 트랜잭션 / 용어 파티셔닝된 보조색인 / NoSQL의 다양한 클러스터 관계형 시스템



트랜잭션이 한 노드에서 한 번 커밋되면 나중에 다른 노드에서 어보트된게 밝혀져도 취소할 수 없다 > 확신할 때만 커밋이 되어야한다.



커밋 후 읽기 격리의 기반 > 커밋된 후에도 어보트 되는게 허용되면



#### 2단계 커밋소개

모든 노드가 커밋되거나 모든 노드가 어보트 되도록 보장하는 알고리즘

참여자(participant) : 데이터베이스 노드를 트랜잭션의 참여자라고한다.

코디네이터(coordinator, 트랜잭션 관리자) : 트랜잭션을 요청하는 애플리케이션 프로세스 내에서 라이브러리 형태로 구현



#### 약속에 관한 시스템

1. 코디네이터에게 트랜잭션 ID 요청함
2. 전역적으로 유일하다 트랜잭션 ID는. 
3. 애플리케이션 커밋 준비가 되면 코디네이터는 모든 참여자에게 전역 트랜잭션ID로 태깅된 준비 요청을 보낸다
4. 참여자가 준비 요청을 받으면 모든 상황에서 분명히 트랜잭션을 커밋할 수 있는지 확인
5. 코디네이터의 결정이 디스크에 쓰여지면 모든 참여자에게 커밋, 어보트 요청이 전송된다. 이 요청이 실패하거나 타임아웃이 되면 코디네이터는 성공할 때까지 영원히 재시도한다



#### 코디네이터 장애

코디네이터가 죽으면?

코디네이터가 준비요청을 보내기 전에 장애가 나면? : 참여자가 안전하게 트랜잭션을 어보트할 수 있다.

참여자가 준비요청을 받고 "네"에 투표했다면 더이상 일방적으로 어보트할 수 없다 : 이상태에 있는 트랜잭션 의심스럽다(in doubt), 불확실하다 (uncertain)

코디네이터에게 듣지 않고 참여자는 커밋할지 어보트할지 알 방법이 없다. > 코디네이터가 복구되기를 기다리는 방법밖에없다.

2PC의 커밋 포인트는 코디네이터에서 보통의 단일 노드 원자적 커밋으로 내려온다



#### 3단계 커밋

2PC = 블로킹 원자적 커밋 프로토콜 : 코디네이터 복구를 기다리느라 멈출수도 있다는 사실 때문에

3PC : 원자성을 보장하지 못한다. 완벽한 장애 감지기 매커니즘이 없다.

2PC 많이 쓰인다



#### 현실의 분산 트랜잭션

평판이 엇갈린다. 운영상의 문제를 일으키고 성능을 떨어뜨리며 그것들이 제공할 수 있는 것보다 더 약속한다고 비판받는다.

- 데이터베이스 내부 분산 트랜잭션 : 데이터베이스 노드 사이에 내부 트랜잭션
- 이종분산 트랜잭션 : 서로 두 가지 서로 다른 벤더의 데이터베이스 등. 시스템 내부가 완전히 달라도 원자적 커밋 보장



#### 정확히 한 번 메시지 처리

**exactly once**

데이터베이스 트랜잭션이 커밋에 성공했을 때만 처리된 것으로 확인.

메시지 확인과 데이터베이스 쓰기를 단일 트랜잭션에 원자적으로 커밋한다.

메시지 전달이나 데이터베이스 트랜잭션 중 하나가 실패하면 둘 다 어보트되고, 메시지 브로커는 나중에 메시지를 안전하게 전달할 수 있다.



분산 트랜잭션 : 모든 시스템이 동일한 원자적 커밋 프로토콜을 사용할 수 있을 때만 가능하다.



#### XA 트랜잭션

X/Open XA(eXtended Architecture의 약자)

XA : 트랜잭션 코디네이터와 연결되는 인터페이스를 제공하는 CAPI 일 뿐이다.

XA를 지원한다 : 연산이 분산 트랜잭션의 일부가 돼야 하는지 알아내기 위해 XA API를 호출한다.



#### 의심스러운 상태에 있는 동안 잠금을 유지하는 문제

의심스러운 트랜잭션은 무시하면 안 될까? **잠금** 과 관련이 있다.

변경한 로우에 로우 수준의 독점적인 잠금을 획득한다. 커밋하거나 어보트 전까지 잠금 해제를 못한다. (코디네이터가 죽어서 재시작할때까지 잠금이 유지가 된다.)



#### 코디네이터 장애에서 복구하기

이론상으로는 로그로부터 상태를 복구하여 트랜잭션 해소해야한다.

트랜잭션 로그 손실이나, 데이터베이스 서버 재부팅으로도 문제 해결이 안될 수 있다 : 관리자가 수동으로 트랜잭션을 커밋하거나 롤백할지 결정하자

XA 구현 

- 경험적 결정(heuristic decision) : 의심스러운 트랜잭션을 어보트하거나 커밋할지 일방적으로 결정할 수 있도록함
- 아마도 원자성을 깰 수 있다 : 장애상황 벗어날 때만 쓰도록하자



#### 분산 트랜잭션의 제약

XA 트랜잭션 : 여러 참여 데이터 시스템이 서로 일관성을 유지하게 하는 문제를 해결해준다.

- 운영상 문제 : 트랜잭션 코디네이터 자체가 죽지 않게 잘 유용
- 코디네이터 복제가 없으면 SPOF
- XA는 광범위한 데이터 시스템과 호환되어야한다
- 데이터베이스 내부 분산 트랜잭션은 그 제한이 크지않다 > 분산 트랜잭션은 장애를 증폭시키는 경향이 있다



#### 내결함성을 지닌 합의

하나 또는 그 이상의 노드들이 값을 제안할 수 있고 합의 알고리즘이 그 값 중 하나를 **결정한다**

합의 알고리즘이 만족해야하는 속성

- 균일 한 동의 : 어떤 두 노드도 다르게 결정하지 않는다
- 무결성 : 어떤 노드도 두 번 결정하지 않는다
- 유효성 : 한 노드가 값을 결정하면 해당 값은 어떤 노드에서 제안된 것이다
- 종료 : 죽지 않은 모든 노드는 결국 어떤 값을 결정한다

독재자 - 노드가 모든 결정을 내리게한다 > 위에 3개 속성을 가볍게 만족한다

> 노드에 장애가 나도 다른 노드들은 여전히 결정을 내려야 한다.

알고리즘이 견딜 수 있는 장애의 수에는 제한이 있다.

종료 속성 : 죽거나 연결할 수 없는 노드 대수가 절반 미만이다.



#### 합의 알고리즘과 전체 순서 브로드 캐스트

알고리즘의 대부분은 값의 순차열에 대해서 결정하여, **전체 순서 브로드캐스트** 알고리즘을 만든다

- 모든 노드에게 메시지가 정확히 한번, 같은 순서로 전달되어야한다.
- 합의를 여러번 반복하는 것과 동일하다



#### 단일 리더 복제와 합의

리더를 운영팀에 있는 사람이 수동으로 선택하면 > 독재자 방식

- 문제 : 현실에서 잘동작하지만 진행하기 위해 사람의 개입이 필요하여 종료 속성을 만족하지 않는다

기존 리더 장애가 나면 팔로워 하나를 새 리더로 승격시켜 자동 리더 선출과 장애 복구를 수행 

- 문제 : 스플릿 브레인 문제



#### 에포크 번호 붙이기와 정족수

리더가 죽었다고 생각할 때마다 노드 사이에서 투표가 시작된다. 이 선출은 에포크 번호를 증가시킨다.

두 가지 다른 에포크에 있는 다 가지 다른 리더 사이에 충돌이 있으면 에포크 번호가 높은 리더가 이긴다.

노드는 에포크 번호가 더 높은 다른 리더를 알지 못할 때만 제안에 찬성하는 투표를 한다

- 리더 선출 투표
- 리더의 제안에 투표

두번의 투표는 정족수가 겹쳐야한다. : 제안에 대한 투표가 성공하면, 그것에 투표한 노드중 최소하나는 가장 최근 리더 선출 투표에도 참여하였다.

2PC : 모든 참여자로부터 투표가 필요 > 내결함성을 지닌 합의 알고리즘 : 노드의 과반수로부터만 투표를 받으면 된다



#### 합의의 제약

합의 알고리즘이 모든 곳에 쓰이지는 않는다.

- 제안이 결정되기 전에 노드가 제안에 투표하는 과정은 일종의 동기식 복제이다.
- 엄격한 과반수 동작을 원한다. 최소한 3대, 5대...
- 네트워크 장애 때문에 어떤 노드들이 다른 노드와 연결이 끊기면 네트워크의 과반수 부분만 진행할 수 있고, 나머지는 차단된다.
- 동적 멤버십 확장 (dynamic membership)
- 장애 노드 감지를 위해 일반적으로 타임아웃에 의존한다. > 잦은 리더선출이 리더 선택에 시간을 더쓰게 될 수 있다.



#### 멤버십과 코드네이션 서비스

주키퍼와 etcd : 완전히 메모리 안에 들어올 수 있는 작은 양의 데이터를 보관하도록 설계되었다.

- 내결함성을 지닌 전체 순서 브로드 캐스트 알고리즘을 사용해 모든 노드에 걸쳐 복제된다.



#### 작업을 노드에 할당하기

리더가 장애가 나면 다른 노드 중 하나가 넘겨받아야 한다. 

단일 리더 데이터베이스, 스케줄러, 상태 저장 시스템에도 유용하다.
파티셔닝 자원, 어떤 파티션을 어느 노드에 할당해야 할지 결정해야하는 경우 등

애플리케이션이 노드가 점점늘어날 수 있음. 이들 노드들끼리 과반수 투표는 매우 비 효율적이다 > 주키퍼는 노드들을 코디네이트 하는 작업의 일부를 외부 서비스에 위탁하는 방법을 제공한다.


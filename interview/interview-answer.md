### 1. 자바 기본타입 참조 타입 차이

primitive : 메모리에 값이 있는 것. (변수가 메모리에 있는 값을 가르킨다.) - 같은 값을 가지면 주소값 같습니다. (Stack 메모리 영역에 실제값을 저장)

int와 Integer

reference : Object class를 상속 받는다. 기본형이 아닌경우 참조형 (객체를 만들고 메모리에서 그 객체의 위치를 갖고있음) - 같은 값을 가지더라도 주소값 다르고 (heap 메모리 영역에 객체를 확보하고 stack 메모리에는 주소값만 있다.)  

reference type 중에 wrapper class가 있음, primitive 타입은 object class를 상속받지 못해 오브젝트 클래스를 인자로 필요로하는 collection객체들은 사용하지못한다. 따라서 이 원시 타입을 한번 감싸서 사용하는 wrapper class 이다.

Integer.valueOf(String ) : reference type의 클래스라고 해도 매번 새로운 객체를 생성하는 것만은 아니다. 이 메서드 안에서는 Integercashed 클래스 안에있는 이미 만들어진 Integer 객체를 참조해서 가져오는 식으로 사용중이다. 그 범위는 low -128 / high 127 로 알고있음.(사람들이 자주사용하는 값을 캐싱해 두었음)





### 2. Exception

Checked exception : 코드단에서 처리해야하는 exception 

(compile error) - IOException : 코드상에서 무조껀 처리해줘야한다.

코드상에서 무조껀 처리해주어야 한다고 하는 이유는, 해당 메서드를 사용했을 때 이런 문제가 있을 수 있으니 주의해서 코딩하라고 개발자에게 알려주는 메세지로 쓰입니다.

즉, 복구할 수 있는 상황에는 checked exception을 던지고

Unchecked exception : 예측이 가능한 exception 

(runtime error) - nullpointexception , indexoutofbound exception

반면 runtimeException의 경우엔 개발자의 실수에 의해 일어나는 것임, 현재 코드에서 더 진행하다간 복구할 수 없는 상황임을 나타낸다.

프로그래밍 오류에는 unchecked exception을 사용해야한다.



### 3. springboot 차이

자동설정을 좀 더 많이 해준다.

@SpringBootApplication 어노테이션 안에 들어있는 각종 Configuration이 스프링 빈설정을 하지 않고도 제공되는 많은 default bean을 만들어 주기 때문.

실제로 H2 의존성을 추가 할 때. 해당 의존성에 맞는 configuration datasource.url, password, username 등을 추가하지 않더라도 기본적인 mem:db 를 사용한다는 url, sa라는 username 을 자동으로 설정해준다.



### 4. 데드락

리소스를 얻어야하는데, 얻지못하고 무한정 기다리는 상태 입니다.

A가 자원1을 갖고있고, B가 자원2를 갖고있는데, A는 자원2를 요청하고, B는 자원1을 요청할때 

- Mutual exclusion 상호 배제 : 자원은 한번에 한 프로세스만 사용한다
- hold and wait : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어있는 자원을 추가로 가져오려고 대기한다.
- no preemption : 다른 프로세스에 할당된 자원은 사용이 끝날 때 까지 강제로 빼앗을 수 없다.
- circular wait : 프로세스 자원간 도식도에서 사이클이 존재





### 5. 쓰레드 세이프란?

쓰레드에서 사용해도 안전하다. 멀티쓰레드 + 동기화

여러 스레드로부터 동시에 접근이 이루어져도 프로그램 실행에 문제가 없다. serialized 를 붙여준다.

두개 쓰레드 1개 자원에 대한 동시요청

- 지연변수는 쓰레드간에 절대로 공유되지 않는다. : 기본형 지역변수는 각 쓰레드의 스택에 저장이 되기 때문이다.
- 지역 객체 참조 : heap영역에 저장이된다. 지역적으로 생성된 객체가 자신의 메서드를 벗어나지 않으면 쓰레드 세이프하다.
- 객체 멤버변수 : 객체를 따라 힙에 저장이 된다. 두개 쓰레드가 같은 객체의 인스턴스 메서드를 호출하고, 두 메서드는 모두 update 하는 로직이라면 쓰레드 세이프 하지 않다.

1. 싱글코어에서 하나의 쓰레드로 두개의 작업 VS 싱글코어에서 두개의 쓰레드로 두개의 작업
2. 멀티코어에서 하나의 쓰레드로 두개의 작업 VS 멀티코어에서 두개의 쓰레드로 두개의 작업

결론부터 말하자면, 1의 경우에는 전자가 빠르며, 2의 경우에는 후자가 빠르다.

문맥교환 때문에 하나의 쓰레드로 두개의 작업을 하는 것이 빠르다.

https://dailyworker.github.io/java-thread/



### volatile, synchronized

동기화에는 두가지가 있다. 배타적 수행, 쓰레드간 통신

volatile은 읽기 시에 어떤 스레드가 값을 변경하든 항상 최신 값을 읽게 하는 것을 (같은 값을 읽도록 보장하는 것)이야기한다. 각 쓰레드에서 값을 읽을 때, 자신만의 저장영역에 캐싱된 값을 읽는다.

따라서 한 쓰레드에서 변경한 값에 대서 다른 쓰레드에서도 읽기 위해서 캐시에서 해당값을 읽지 않고 메모리에서 그 값을 읽어서 쓰레드간 통신을 한다.

실제로 volatile의 예제로 long, double이 있는데 이는 64비트로 저장된 데이터를 JVM 32비트체계에서 원자적으로 읽게 해준다.

##### 동기화의 경우에 자바 메모모리 모델의 reordering

volatile 변수에 대한 쓰기는 임의의 쓰레드에 의해 해당 변수를 subsequent read(동기화 순서에 의해 정의된 read)를 하여 동기화된다. -> volatile 변수의 변경 사항은 항상 다른 쓰레드에 표시된다.



### 6. TCP와 UDP의 차이점

TCP : 연결기반 - virtual path 

서버와 클라이언트 사이에 연결을 맺고, 해당 연결에 해당하는 가상의 경로를 생성한다. 이경로를 따라 데이터를 순차적으로 하나하나 보낸다.

TCP의 헤더에는 sync num, ack num 등 신뢰성을 보장하기 위한 요소들을 저장하기 위한 공간이 있는데, 이 숫자들을 보고 순차적으로 데이터가 오지 않았을 때 재전송을 보내는 등의 조치를 취하기 때문에 신뢰성이 크다.

하지만 신뢰성을 위해 헤더의 크기가 방대해지고, 연결 기반으로 통신이 진행되기 때문에 속도가 느리다.

UDP :

목적지 기반으로 데이터를 전송한다. 서버와 클라이언트 사이에 연결이 없어도 목적지의 ip, port 기반으로 전송을 한다.

헤더에 address 정보 외에는 없으며 연결이 이루어지지 않기 때문에 속도가 빠르다



### http2.0 vs http1.1

랜딩속도! 속도의 변화가 크게 생겨났다.

웹페이지의 리소스의 크기가 엄청 늘어났다. 그리고 웹페이지가 동적으로 작동된다.

http1이 느린 이유 : 앞에서 날린 요청의 응답을 받아야만 다음 요청이 처리될 수 있다.

- 1에서는 처음에 요청한 request에 문제가 있어서 응답이 늦어지면, 2번째 3번째 요청한 request의 응답도 같이 늦어진다.

이를 개선하고 싶었다

- 프로그래머는 서버는 같지만 도메인 명을 여러개 설정해서 이를 주소로 내려주면 다른 곳으로 요청을 보내는 것이기 때문에 여러개의 커넥션을 맺을 수 있다했다.

Multiplexing 개념이 도입되었다.

- 동시에 여러 리소스를 받아올 수 있게 되었다. 한 커넥션에서 여러 리소스를 동시에 받아올 수 있다.

https://evan-moon.github.io/2019/10/08/what-is-http3/



### 유니 캐스트, 브로드 캐스트, 멀티 캐스트

- 유니케이스: 1대1로 데이터를 전달하는 통신 방식, 자신의 mac 주소, 목적지 mac 주소를 첨부한다.

  네트워크 안 모든 시스템은 mac 주소를 받아서 자신의 mac주소와 비교후에 같지 않으면 프레임을 버린다.

- 브로드 캐스트: 같은 네트워크 서식지에 있는 모든 PC에게 데이터를 주는 방식
  
  브로드 캐스트용 주소가 미리정해져있고, 수신 받는 시스템은 이주소가 오면 처리한다.
  라우터끼리 정보 교환 혹은 새로운 라우터 찾기에 이용된다.
  
- 멀티 캐스트 : 200명 사용자가 있는 곳에서 150명의 사용자에게만 데이터를 주고싶을 때의 통신방식

  멀티 캐스트 전송을 위해서는 헤더에 수신자의 주소 대신 수신자들이 참여하는 그룹 주소를 표시해 패킷을 전송한다.

  UDP를 사용해 전송하여 신뢰성을 보장받지 못한다.

  하나의 클라이언트에서 여러 멀티캐스트 주소를 수용할 수 있다

  Class D IP 주소 사용



### IP 클래스

| **구분** | **2진수 시작은? (s 네트워크, h 호스트)**                     | **네트워크 시작번호 (개수)**                   | **호스트 범위 (개수)**                        |
| -------- | ------------------------------------------------------------ | ---------------------------------------------- | --------------------------------------------- |
| A클래스  | **0sss ssss. hhhh hhhh. hhhh hhhh. hhhh hhhh**(0 시작, 네트워크 : 7bit, 호스트 : 24bit) | **1 ~ 126 시작** (2^7 -1 개 : 127은 제외라 -1) | 2^24 -2 (-2 네트워크, 브로드캐스트 주소 제외) |
| B클래스  | **10ss ssss .ssss ssss. hhhh hhhh. hhhh hhhh**(10 시작, 네트워크 : 14bit, 호스트 : 16bit) | **128.0 ~ 191.255 시작**(2^14 개)              | 2^16 -2 (-2 네트워크, 브로드캐스트 주소 제외) |
| C클래스  | **110s ssss. ssss ssss. ssss ssss. hhhh hhhh**(110 시작, 네트워크 : 22bit, 호스트 : 8bit) | **192.0.0 ~ 223.255.255 시작**(2^22 개)        | 2^8 -2 (-2 네트워크, 브로드캐스트 주소 제외)  |

***(네트워크 범위가 커질수록 호스트 주소 범위는 작아짐 반비례 관계)***



### 7. 스택, 큐, 퀵소트

스택 : first in last out

큐 : first in first out

퀵소트 : 공간 복잡도 O(n) / 시간복잡도 O(Nlogn) : pivot 선정 -> 기준보다 크면 왼쪽 작으면 오른쪽 -> 정렬될때까지 분할 처리 -> O(N^2)



### 10. 파일시스템 / 데이터베이스의 차이점

파일시스템 : 데이터를 접근하고 조작하는 기능만 있다.

- 데이터 불일치, 
- 다수 사용자 불가능, 
- 쉬운 질의어 없음, 
- 보안기능 미흡: 기껏해봐야 암호

데이터베이스 : 파일 시스템의 단점을 개선하기 위한 것 -

-  데이터 일치, 다수 사용자 가능, 
- 쉬운 질의어, 
- 보안기능 있음 : 유저별 권한



### 11. 스프링 DI, IOC, AOP

**IOC**

객체를 생성하고 소멸시키는 권한이 사용자에게 있는게 아니라 스프링 컨테이너가 대신 해준다.

제어권이 객체 자신이 아닌, 스프링에게 넘어갔기 때문에 IOC라고한다.  (프로그램 제어 흐름구조가 바뀐다.) 스프링 컨테이너가 빈으로 등록된 객체에 한에서 제어를 해준다. 여러 객체를 bean 컨테이너로 관리한다 (bean은 object!!)

@Controller, @Service, @Repository 등의 빈으로 등록된 객체라면 spring container에서 객체의 생명주기를 관리합니다.

제어건이 스프링으로 넘어가서 DI를 해주게됩니다.



**DI**

그 객체가 필요할 때 메서드 안에서 생성해서 사용하는 것이 아닌, 그 객체가 외부에서 생성이 되어있다 치고, argument로 주입받아서 생성되어있는 객체를 사용한다는 개념이다.

인스턴스를 자신이 아닌 IOC 컨테이너에서 생성한 후에, 그 인스턴스를 주입합니다.

객체간 의존성을 내가 아니라 외부에서 주입하는 개념.

내부적으로는 new 키워드대신, contructer나 setter를 이용해서 주입합니다.

- field injection

  애플리케이션 정상 구동 후에 run 메서드에서 stackoverflowerror를 뱉으면서 종료한다.

  먼저 빈을 생성한 후에 어노테이션이 붙은 필드에 해당하는 빈을 찾아 주입한다.

- constructor injection

  순환 참조를 방지할 수 있다. (BeanCurrentlyInCreationException : 애플리케이션 구동도 안된다.)

  생성자로 객체를 생성하는 시점에 필요한 빈을 주입한다.

  생성자의 인자에 사용되는 빈을 찾거나 빈 팩터리에서 만든다. 그 후에 찾은 빈의 생성자를 호출한다.

  - 의존 관계가 명시적으로 드러난다 : 나쁜 냄새를 없앤다.
  - 테스트에 용이하다 : mockito 혹은 단순 pojo 테스트를 할 수 있다.
  - final 선언으로 불변성



##### AOP

관점지향 프로그래밍이다. 애플리케이션 전체에 걸쳐서 사용되는 기능을 재사용할 수 있게 하는 것이다.

각각의 핵심 기능인 서비스에서 바라봤을때는 공통된 요소가 없을 수 있지만, 부가기능이라는 관점에서보면 공통된 기능이 있을 수 있습니다.

예를들어 모든 서비스에서 트랜잭션이나, 로깅, 예외처리와 같이 공통적인 부분을 분리해서 관리하는 것을 의미한다. 

Aspect 를 이용해서 Before, After 메서드 실행 전 후 사용될 기능을 정의한다거나 하는 것을 알 수 있음.



### 12. filter interceptor aop

Interceptor와 Filter는 Servlet 단위에서 실행된다. <> 반면 AOP는 메소드 앞에 Proxy패턴의 형태로 실행된다.

filter > dispatcher servlet > interceptor > aop > controller

filter : doFilter (Servlet request, Servlet response )

- servlet에서 실행
- 전체적인 request에서 어떤 처리가 필요할 때(문자 인코딩)
- dispatcher servlet 이전에 실행이 되고, 이 앞단에서 요청 내용에 대한 체크를 수행할 수 있음. url 에 따른 blocking 등의 설정
- ip, hostname, 서버이름, 포트번호 컨텐츠 타입 등을 가져올 수 있다.

interceptor : preHandler, postHandler / (HttpServletRequest, HttpServletResponse)

- servlet에서 실행
- 세션 쿠키 체크가 http 프로토콜 단위로 처리해야할 때 > 로그인 세션 체크 
- http 헤더, 세션 쿠키 데이터, url 등을 가져올 수 있다.
- dispatcher servlet이 컨트롤러를 호출하기 전 후로 끼어든다. 로그인 체크 권한 체크 등을 사용할 수 있음. 스프링 컨텍스트 내부에서 컨트롤러 요청 응답에 대한 처리를 맡는다.

aop

- 메서드에서 실행
- 비즈니스 단에서 세밀 조절이 필요할 때
- 객체 지향 프로그래밍에서 중복을 줄일 수 없는 부분을 종단면 관점에서 바라보고 처리한 것
- 로깅 트랜잭션등에 대한 조정에서 사용한다.
- 메서드 전후 지점에 자유롭게 설정이 가능하다. (주소, 파라미터, 애너테이션 등의 방법으로 대상 지정이 가능하다.) <-> filter interceptor는 주소로만 판단이 가능하다.



### spring filter vs Interceptor

filter는 dispatcherservlet 앞에 있고, interceptor는 handler단인 controller 이젠에 있다.

- filter : 들어오는 url 자체를 거른다. url-pattern 등을 이용할 수 있다.

- interceptor: 세션에 대한 체크, 인증처리에서 사용한다 // filter와는 다르게 controller 전 후 과정이 있다.

  필터와는 다르게 분기가 명확하다. handlerMapper에서 이미 controller의 메서드를 찾아낸 이후에, 해당하는 controller 메서드 url에 대해 이미 등록된 interceptor와 매칭되는 것을 찾아낸후, preHandle => controller => postHandle 과정으로 수행된다.



### JPA 영속성 컨텍스트 생명주기

https://doublesprogramming.tistory.com/259

비영속(new) : 영속성 컨텍스트와 관련이 없는 상태

영속(managed) : 영속성 컨텍스트에 저장된 상태 : persist, find 상태, >flush(등록)

- 1차 캐시 : 1차 캐시에 존재하는 엔티티 조회시 영속성 컨텍스트에서 가져온다.
- commit 하는 순간 SQL을 DB에 보낸다
- 수정 변경 감지, 수정된 경우에 commit하면 update한다.
- 삭제쿼리를 저장해둔 후 commit하면 삭제쿼리를 날린다.

준영속(detached) : 영속성 컨텍스트에 저장되었다 분리된 상태 : 영속상태의 엔티티를 영속성 컨텍스트가 관리하지 않을 때 > detach, clear

삭제(removed) : 삭제된 상태 : remove : 영속성 컨텍스트와 디비 모두에서 삭제

##### 플러시

영속성 컨텍스트의 변경 내용을 DB에 반영한다.

1. 트랜잭션 커민
2. 변경 감지된 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교한다. 
3. 수정된 엔티티는 수정쿼리를 만들어 지연 SQL 저장소에 등록한다.
4. 지연 SQL을 DB에 전송한다
5. DB 트랜잭션을 커밋한다.





### 12. Thread

한 프로세스를 여러개의 스레드로 구성하고, 각 스레드별로 하나의 작업을 처리한다.

- 설계, 디버깅 까다롭다. 테스트코드를 어떻게 짜지
- 동기화문제 발생 (자원 공유 문제) 
- 한개의 쓰레드 문제가 생기면 전체 프로세스 영향

구현 방법 : Thread 클래스 상속 or Runnable클래스 상속으로 run() 메소드 재정의



### 13. Map vs List

<https://gangnam-americano.tistory.com/41>

Set : 순서가 없다. 중복이 없다.

- HashSet : 가장 빠르다. 순서를 예측할 수 없다. : 데이터 유무 판단에 중점을 두었다.
- TreeSet : 정렬방법 지정이 된다. - 바이너리 서치트리의 형태로 정렬이 된다.

List: 순서 있다. 중복 있다. (특정 동일 공간에 뭉텅이로 저장한다)

- ArrayList : 단방향 포인터 구조, 인덱스가 있다. : 조회에 좋다. : : thread safe
- LinkedList : 양방향 포인터 구조, (스택, 큐, De큐에 사용된다.) 
- Vector : 어레이리스트 구조에 내부에서 자동 동기화 처리 : thread safe하지 않다.

Map 아이템 저장할 떄마다 빈공간을 찾는다.

- HashTable : 동기화를 지원한다
- HashMap : 동기화를 지원하지 않는다.
- TreeMap : 정렬된 순서대로 키 값을 지정해 검색이 빠르다

List : Memory안 특정 동일 공간에 뭉텅이 저장 : 데이터 저장속도 빠르다.

Map : 아이템을 저장할 때 마다 빈공간을 찾아 어장 : 데이터 저장속도 느리다. Entity를 이용한다.

https://joooootopia.tistory.com/13



### 14. Thread pool

스레드가 생성될때 : OS가 받아들여 메모리 확보하고, 메모리를 스레드에 할당 (이 비용!!!)

쓰레드를 미리 만들어두고, 필요할 때 하나씩 갖다 쓰는 것.



### 15. 테스트코드가 중요한 이유

기능에 대한 명세가 이루어진다.  = API DOC과 같은 것

project를 받자마자 API문서도 없는 상황에서 이해를 해야할 것 

기능을 BM에 맞게 수정했더니 다른 기능이 안되는 상황을 방지하기 위함



### 16. 유닛테스트와 통합테스트의 차이

유닛테스트

 - java pojo파일에 구현해둔 로직에 대한 테스트를 한다. 
 - 시간이 적게 걸린다.
 - 함수 하나하나와 같이 코드의 작은 부분을 테스트하는 것
 - string을 replace하는 작은 로직이라도 불확실성이 제거된다.
 - 디버깅 시간을 줄일 수 있다.
 - 슬라이싱 테스트 : repository, service(mockito), controller 각 영역에 해당하는 부분의 빈만 띄워서 테스트한다.
   - service : mockito, repository given, then으로 메서드에 대한 액션을 정의해 둔다. service는 Mockbean으로 DI injection 한다.
   - controller : webMVC Test 를 이용. mockmvc.perform 메서드를 활용해서 given, expectedResult 를 활용해서 status 값을 체크한다.
   - repository : datajpaTest, queryDSL로작성한 customrepository가 잘 동작하는지 확인



통합테스트

 - spring을 띄운다. POSTMAN으로도 가능하기는 하다.
 - 시간이 오래걸린다.





### 17. TDD 유닛테스트 차이

방식의 차이

TDD는 Test Driven Develop : 테스트를 먼저 만들고 테스트를 통과하지 위한 것을 짠다.

유닛테스트 : 구현을 먼저 짜고 테스트를 짠다.



### 18. 멀티쓰레드 vs 싱글쓰레드

싱글쓰레드 : 하나의 쓰레드로 두개의 작업을 하는 경우 : 한 작업이 마친 후 다른 작업을 시작

멀티쓰레드 : 두개의 쓰레드로 두개의 작업을 할 때 : 짧은 시간동안 2개의 쓰레드가 번갈아가면서 처리되서 동시에 두작업이 처리되는 것처럼 보인다.

수행시간은 같다.

간단 -> 싱글 쓰레드 good

자원공유가 많이 이루어지는 작업이면 멀티쓰레드가 효율적 : 외부 기기와 같은 입출력을 필요로 하는 경우
네트워크로 데이터를 주고받는 작업 (멀티쓰레드) - 요청을 처리하는 네트워크 쪽 서버에 사용

멀티쓰레드의 경우에는 context switching 시간이 걸린다. 쓰레드간 전환이 필요함. 

**code data stack heap**



### 19. 멀티 쓰레드, 멀티 프로세스

##### 멀티 프로세스

하나의 프로그램을 여러 프로세스로 구성하는 것,

Context switching 작업에서 캐시에 잇는 모든 데이터를 리셋하고 모든 캐시정보를 불러와야한다. 프로세스는 각각 독립된 메모리 영역을 할당받았기 때문에 (프로세스 사이 공유하는 메모리가 없어서)

- cpu 레지스터 교체 뿐만 아니라, ram cpu사이 캐시 메모리도 초기화 되서 오버헤드가 크다 (stack, data, heap, code 영역모두 context switching)

##### 멀티 스레드

하나의 프로그램을 여러개 스레드로 구성하는ㄱ 서

스레드 사이 작업량이 작아 context switching이 빠르다. 자원 공유 문제가 발생한다(동기화 문제)

공유자원으로 code, data, heap이 있기 때문에 자원을 공유한다. 공유하는 만큼 자원을 할당하는 시스템 콜이 줄어들어 효율적 관리가 된다.

- 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 다르게 스레드간 데이터를 주고 받는게 간단하고 시스템 자원 소모가 줄어든다. (stack 영역만 context switching)



### 19. WAS VS WebServer

Web Server Http를 통해 웹 브라우저에서 요청하는 html css image 파일등의 정적 컨텐츠를 전송해 주는 서버 : 아파치, nginx

WAS : http를 통해 **애플리케이션을 수행**시켜주는 것 Webserver의 기능을 포함하고 있다. 동적으로 서버 컨텐츠를 수행한다 : 서블릿 컨테이너, 웹서버와 연동하여 실행할 수 있는 어플리케이션 환경을 제공한다. : tomcat



### 21. Nginx

아파치 : 요청하나당 쓰레드 하나가 처리 / 사용자 많으면 많은 쓰레드 생성 / 하나의 쓰레드 = 하나의 클라이언트

nginx : 비동기, 이벤트 드리븐 기반 / 다수의 연결을 효과적으로 처리 / 더작은 쓰레드로 클라이언트 요청 처리

nginx를 프록시 서버로 앞단에 두고, node.js를 뒤쪽에 두자. 보안적 부분을 처리할 수 있다.



### 프레임워크 vs 라이브러리

프레임워크는 라이브러리의 집함에 **제어흐름의 주도성**까지 갖고있는 것을 의미한다. 어플리케이션의 흐름을 프레임워크가 갖고있다. 사용자는 프레임워크의 흐름이 이용해서 코드를 짠다.

spring boot를 쓰다가, 내장된 라이브러리인 jedis의 버전이 3점대인게 싫어서, lettuce로 갈아끼우는 작업을 하는 것과

반면 라이브러리는 사용자가 전체적인 흐름을 만들고 라이브러리를 가져다 쓰는 것을 말한다. 애초에 lettuce를 사용하되, 그걸 어떻게 실행하고 어떻게 return하고를 사용자가 짜야하는 문제는 다르다.



### 캐싱

디비에서 읽기 전략은 join등 시간이 오래걸리는 경우가 많다.

왜냐하면 DB는 파일시스템에 데이터를 저장하는 것이기 때문에, 반면 캐시는 메모리에 있는 데이터를 읽어고고 저장하는 것이기 때문에 DB보다 훨씬 빠르다. 

따라서 나의 캐싱 전략은 DB에서 조회가 일어난 건수가 있다면 캐시에 저장을하고 유효시간을 정해둔다. 유효시간이 지나기 전에 같은 조회가 일어나면 캐시에서 데이터를 가져와서 좀더 빠르게 조회를 할 수 있다.



### JDBC 드라이버, 커넥션풀

#### JDBC 드라이버

java 내에서 DB와 관련된 작업들을 처리할 수 있도록 도와주는 일을 한다.

DB와의 통신에 필요한 API들의 구현체이다. 
DBMS별로 알맞는 JDBC드라이버가 필요하다.

com.mysql.jdbc.Driver 이런식으로 로드한다.

#### 커넥션 풀

커넥션 풀 : DB와 연결하는 커넥션들을 미리 생성해두고 풀에 저장해둔다. DB와 연결할 때 TCP 커넥션을 하기 때문에 연결에 걸리는 시간이 오래걸려, 성능을 위해 미리 풀에 저장해두는 것이다.

- DB connection 생성, 제거는 시스템에 부담을 주는 작업이다.ㄷ
- 연결 관리, 동시 Connection 들의 수를 설정하여, 그 이상으로 시도했을 때 DB에 부하를 주는 작업을 막는다.



### DB 격리레벨

https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation>

##### read uncommited

각 트랜잭션에서 변경내용이 commit, rollback 상관없이 다른 트랜잭션에서 값을 읽을 수 있다.

commit이 되지 않은 상황이지만 update된 값을 다른 트랜잭션에서 값을 읽을 수 있다.

**(Dirty Read)** : 커밋되지 않고 종료되면 T2가 가진 데이터는 꼬인다. 트랜잭션 작업이 완료되지 않았음에도 다른 트랜잭션에서 볼 수 있다.



##### read commited

RDB에서 대부분 이렇게 사용한다.

커밋이 완료된 데이터만 읽을 수 있다.

실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다. 

commit되기 이전과 이후에 읽었을 때 같은 결과가 아니다. (입출금에서 유의)

**(Non Repeatable Read)** : T1이 read하는데, 이때 다른 T2가 접근해서 값을 변경, 삭제하고 커밋하면 
T1이 해당 데이터를 read하고자하면, 변경된 혹은 사라진 데이터를 찾게된다.

하나의 트랜잭션에서 같은 select 쿼리를 실행했을 때 항상 같은 결과를 가져와야하는 repeatable read의 정합성에 어긋난다.



##### repeatable read

트랜잭션 내에서 한번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다.

트랜잭션마다 트랜잭션 ID를 부여하여, 트랜잭션 ID보다 **작은 트랜잭션 번호에서 변경한 것만 읽는다.**

즉 읽기 트랜잭션이 10이고, 업데이트 트랜잭션이 12일때, 읽기 트랜잭션에서 여전히 10을 가지면 바뀐값을 읽지 않는다.

**(Phantom read)** :T1에서 특정 조건으로 데이터를 검색해서 결과를 얻음. 이때 T2가 접근해서 해당 조건의 데이터 일부를 삭제, 추가했을 때 아직 끝나지 않은 T1이 해당 조건으로 데이터를 조회하면, T2에서 추가 삭제된 데이터가 함께 조회 누락된다.

##### serializable

가장 엄격하게 처리한다. 그러나 동시 처리 성능이 급격히 떨어진다. 병렬적으로 실행이 되지 못함.



### 트랜잭션 고립레벨

트랜잭션의 이상 읽기 현상

Dirty Read : A = 5로 update하고 커밋을 안했는데, 다른 트랜잭션이 이 값을 읽으면 잘못된 갓ㅂ이 나온다. (5로 읽는다.)

공유 lock을 걸어서, T1 처리동안 다른 트랜잭션 접근 못하게한다.

Non Repeatable Read : T1이 같은 쿼리를 두번 실행했는데 그 결과값이 다른경우 // T1이 select 2번했는데, T2가 그사이에 update delete 한 경우 

트랜잭션 완료때까지 수정 삭제를 제한한다.

Phantom Read

T1 트랜잭션은 같은 쿼리를 두번 실행했는데, 없던 레코드가 두번째에서 튀어나옴

트랜잭션 완료될가지 수정, 삭제, 삽입 불허한다.



Read Uncommited : D가능, NR 가능, P가능 [동시성이 커진다] : 커밋 안한걸 리드하는걸 허용한다.

Read Committed : D 불가능 , NR 가능, P가능 : 커밋한거만 리드하는걸 허용한다.

Repeatable Read : D불가능, NR불가능, P가능 : 트랜잭션이 종료될때까지 다른게 삽입하는거만 허한다.

Serializeable : D불가능, NRq불가능, P불가능 [병렬적으로 실행되지 못함 - 성능문제] : 모든걸 불허한다.



### DB ACID

- 원자성 : 한 트랜잭션은 한 작업이다. 모두 성공 또는 모두 실패!
- 일관성 : 모든 트랜잭션은 일관적인 DB상태유지 : DB에서 정한 무결성 조건을 항상 만족한다.
- 격리성 : 동시에 실행되는 트랜잭션이 서로 영향주지 않게한다
- 지속성 : 트랜잭션을 성공적으로 마치면 항상 저장된다.



### PK UK 차이

PK 

- 테이블에서 대표되는 key 
- 해당 컬럼은 unique하고 notnull 이어야한다
- Null 입력이 안된다.
- clustered index



UK

- 테이블에서 여러개를 생성할 수 있다.


- 테이블에서 해당 컬럼에 unique하다.
- null 중복 허용
- non-clustered index



### clustered index nonclustered index

클러스터드 인덱스

- 테이블 당 한개만 생성이 가능하다.
- 행 데이터를 인덱스로 지정한 열에 맞춰서 자동 정렬한다. (index 대로 정렬)
- 인덱스를 생성할 때 데이터 페이지 전체를 다시 정렬한다. 성능이 좋다.



논클러스터드 인덱스

- 테이블당 여러개를 생성할 수 있다.
- leaf level의 인덱스 테이블이 새로 생긴다. : 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구현한다.



### 9. 클러스터드 인덱스 / 논 클러스터드 인덱스

클러스터드 인덱스

- 물리적으로 행을 재 배열한다 : PK는 자동적으로 생성된다.-> 실제 DB의 데이터 파일에 정렬이 되어있는 상태로 디스크에 저장이 된다.
- 테이블당 1개만 존재한다.
- 논 클러스터드 인덱스 페이지 용량보다 작다
- ![img](https://t1.daumcdn.net/cfile/tistory/265E6C3951C7F4460C)

논 클러스터드 인덱스

- 물리적으로 행을 재 배열하지 않는다.
- 테이블 당 여러개가 존재할 수 있다.
- 클러스터드 인덱스 페이지 용량보다 크다
- 조회문 성능 향상을 위해 사용되지만 실제 물리적으로 정렬되어 저장되지는 않는다.
- 별도의 공간에 인덱스 테이블을 생성하여 데이터를 정렬한다.
- ![img](https://t1.daumcdn.net/cfile/tistory/03753C3451C7F4311D)

789 추출 할 때? 

- 클러스터드 인덱스는 한번에 데이터를 추출 할 수 있다 모두 3페이지에 존재하기 때문이다.
- 넌 클러스터드 인덱스는 한번에 데이터를 추출 할 수 없다. 정렬되어있는 인덱스 페이지를 찾아가더라도, 해당 인덱스 페이지가 참조하는 데이터 페이지로 한번더 거쳐야하기 때문이다. 위의 경우에는 2번이다.

### 인덱스

검색을 위해 fullscan이 아니라, 인덱스가 적용된 컬럼의 테이블을 따로 파일로 저장해 두고, 이를 검색해서 효율을 높인다.

범위스캔을 한다 : 특정 값을 찾다가 해당 범위를 넘어서는 값을 만나면 멈춘다.

인덱스를 저장하는 블럭이 트리구조를 이룬다. Root block > branch block > leaf block 순이다.

**B-tree B+-tree** : branch block에서 가장 왼쪽 값보다 작거나 같을 때는 왼쪽 포인터, branch block 사이에 있으면 사이 포인터, branch block에서 가장 큰 값보다 크면 오른쪽 포인터로 찾아간다 : 그리고 leaf node에서 순서대로 linkedlist로 정렬이 되어있다.

인덱스는 select 문의 where join에서 성능 발휘

insert, update, delete에서 성능이 떨어진다.

insert의 경우 새 데이터 삽입과 같이 인덱스 테이블에도 생성을 해야해서! (key 값을 옮길때 모든 과정을 해야한다.)

delete : 인덱스 테이블에서 사용안함 표시만 하고 자리를 그대로 차지할 수 있어서 유념해야한다.

update : delete 하고 insert하는 식으로 처리함.



### DB 샤딩

같은 테이블 스키마를 가진 것을 여러 DB에 분산하여 저장하는 것

즉 정자동 주민테이블은 A DB에 서현동 주민테이블은 B DB에 저장되게 한다.

물리적으로 다른 데이터 베이스에 데이터를 수평분할 방식으로 분산 저장하고 조회하는 방법을 말한다.

인덱스 크기를 줄이고 작업 동시성을 늘리기 위함이다.

Horizontal partitioning : 스키마가 같은 데이터를 두개 이상 테이블에 나누어 저장

- 고스펙 컴퓨터 만들기

- Data Repelication 적용하기 (Read 명령이 많으면 cache나 database replication 적용하기 )
 (master, slave) : master는 insert update delete 수행 / slave는 select 수행
  slave는 master의 내용을 복사한다.
  
- algorithm sharding : DB ID로 단순히 나눈다 (key % num_DB) :

   노드 개수가 변하게 되면 resharding이 필요하다.

- Dynamic sharding : 클라이언트가 locator에 접근해서 해당 key를 얻는다. : 1~100은 A DB 이런식으로

  locator에서는 해당 key의 range는 어느 디비에 들어가있고를 알 수 있다.



### 트랜잭션

트랜잭션의 효과를 데이터베이스에 확정 하기→ commit

트랜잭션의 효과를 테이터베이스에 취소하기 → rollback



어노테이션 방식으로 @Transactional : 선언적 트랜잭션

해당 클래스에 트랜잭션 기능이 적용된 프록시 객체가 생성되고, 해당 메서드가 호출되면 PlatformTransactionManager를 사용해서 트랜잭션을 시작하고

정상여부에 따라 commit 또는 rollback한다.

##### 속성

- isolation : 격리 수준

  일관성 없는 데이터 허용 수준

  ```java
  @Transactional(isolation=Isolation.DEFAULT)
  ```

- progapation : 전파 옵션

  트랜 잭션 동작 도중 다른 트랜잭션을 호출하는 상황에 선택하는 옵션

- readOnly 

  트랜잭션을 읽기 전용으로 설정한다. : insert, update, delete 발생시 예외가 발생한다.

- Rollback-for : 롤백 예외

  선언적 트랜잭션에서 런타임 예외가 발생하면 롤백한다. 반면 체크예외면 커밋한다.
  특정 예외 발생시 강제로 rollback하게 할 수 있다.



### DB 무결성(integerity)

데이터의 정확성 일관성 유효성이 유지되는것

- 개체 무결성(entity integrity)

  모든 테이블이 PK로 설정된 column이 있어야한다. PK는 notnull, unique하다.

- 참조 무결성(referential integrity)

  참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 가져야한다.

  어떤 외래키 B가 A를 참조하면, A는 반드시 DB에 존재한다.

  - cascade: 레코드를 변경 삭제하면 해당 레코드를 참조하는 개체도 변경 삭제한다.
  - restricted: 레코드를 변경 삭제할 때, 해당 레코드를 참조하는 개체가 잇으면 해당 연산을 취소한다.
  - set null : 레코드를 변경 삭제하면 해당 레코드를 참조하는 개체의 값을 null로 설정한다.

- 도메인 무결성(domain integrity)

  올바른 데이터 값이 입력되었는지를 확인하는것 제약사항을 걸어 보장한다.

   null 확인, 필드 타입 확인, 주민등록번호 필드에에 알파벳만 입력되는 경우

- 무결성 규칙

  데이터 무결성을 지키기 위한 모든 제약사항

  모든 데이터는 Business Rule을 준수한다



### DB 정규화

https://3months.tistory.com/193

불필요한 데이터를 제거한다 중복을 최소화 한다.

데이터 테이블의 구성이 논리적이고 직관적이다.

삽입 갱신 삭제시 발생하는 각종 이상현상을 방지한다.

- 1차 정규화

  컬럼에 원자값만 갖는다. (A,B) > (A)(B)

- 2차 정규화

  본키중에 특정 컬럼에만 종속된 컬럼**(부분적 종속)이 없어야 한다**

  subject student age 가 있을 때

  student를 알면 age를 알 수 있음. 따라서 age가 두번 들어가는것은 불필요한것으로 본다.

  테이블을 쪼갠다 (student age) (student subject)

  기본키 하나?

- 3차 정규화

  본키 이외의 다른 컬럼이 그외 다른 컬럼을 결정할 수 없는 것입니다.

  (student_id, student_name, zip, street, city, state)에서

  데이터를 논리적인 단위로 분리한다.

  (student_id, student_name, zip)

  (zip, street, city, state)

- BCNF

  (학생, 과목, 교수, 학점)

  (교수, 과목)

  (학생, 과목, 학점)



### blue/green 배포, Canary 배포

##### 블루그린 배포

구버전(블루버전)과 새버전(그린버전)의 서버를 나란히 놓고, 배포 시점이 되면 한번에 구버전에서 새버전으로 바꾼다. 

##### 카나리 배포

카나리는 위험을 감지할 수 있는 배포 기법.

구버전과 새버전의 서버를 구성하고 일부 트래픽만 새버전으로 보내서 오류 여부를 판단한다. 100 > 90/10 > 50/50 > 10/90 > 100 으로 점차적으로 새버전으로 트래픽을 옮겨가면서 배포한다.



### 페이지 교체 알고리즘

- **LRU 알고리즘** - least recently used : 페이지 크기가 3이고, 0~4가 참조될 때, 가장 최근에 사용되지 않은 것을 지운다는 것입니다.
- **LFU 알고리즘** - least frequently used: 참조횟수가 가장 작은 페이지를 교체한다.
- **MFT 알고리즘** - most frequently used : 참조 횟수가 가장 많은 페이지를 교체한다.



### Rest API

##### options

- 특정 엔드 포인트가 어떤 메서드를 허용하는지 알고자 할 때 사용한다.
- 405를 방지하기 위해 OPTIONS를 사용한다.

http 기반으로 필요한 자원에 대한 요청을 보낸다.

자원을 정의하고, 자원에 대한 주소를 지정하는 방법론.

- 자원(resource) : URL
- 행위(method) : 서버에 요청을 보내기 위한 방식 GET, POST, PUT, DELETE (처리를 위한 연산에 맞는 메서드를 보낸다.)
- 표현(representations) : 클라이언트와서버가 데이터를 주고받는 형태(json, xml 등등)

http 메서드를 사용한다. GET, POST, PUT, DELETE 4개 메서드로 접근 한다.



**hateoas(헤이토스)** : 진정한 rest api에 작성해야한다. 클라이언트에서 해당 리소스와 관련된 리소스에 대한 링크를 지원하는 것. 다음 단계 작업을 위한 리소스 URL을 알려준다.

- 서버: 현재 리소스와 **연관된 링크 정보**를 클라이언트에게 제공한다.

- 클라이언트: **연관된 링크 정보**를 바탕으로 리소스에 접근한다.

  root 와 연관된 링크는 이런게 있구나를 파악하고, book으로 가고싶으면 book 관련 Relation에 해당 relation에 해당하는 href (하이퍼 텍스트 레퍼런스) 로 간다.


head: 요청에 대한 header 정보만 응답한다



1. Uniform Interface
   편리하고 단순하다. URL로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행할 수 있다.
2. Stateless(무상태성)
   상태의 정보를 저장하고 관리하지 않는다. 들어오는 요청만 단순히 처리하면 된다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해진다.
3. Cacheable
   가장 큰 특징중 하나인 HTTP라는 기존 웹표준을 그대로 사용하기 때문에 웹에서 사용하는 기존 인프라를 그대로 사용할 수 있다.
4. Self-descriptiveness(자체표현구조)
   REST API 메시지만 보고도 이를 쉽게 이해할 수 있는 자체 표현구조로 되어있다.
5. Client - Server 구조
   서버는 API를 제공, 클라이언트는 사용자 인증이나 컨텍스트를 직접관리하면서 역할이 구분되기 때문에 개발해야할 내용이 명확해지고 의존성이 줄어들며 생산성있는 개발이 가능하게 된다.



### CORS

SOP : single d

- Single-Origin Policy > 이걸 우회하기 위한 표준 기술이 CORS이다. : 같은 Origin에만 요청을 보낼 수 있다.
- Cross-Origin Resource Sharing : 서로 다른 Origin 끼리도 resource를 공유할 수 있다.
  - URI 스키마 (http, https)
  - hostname (whiteship.me, localhost)
  - 포트 (8080, 18080)
- 기본적으로 SOP가 적용되어있다. 그래서 허용가능한 origin을 설정해주어야 한다.
- header에 Access-control-allow-origin을 추가해서 보내준다.
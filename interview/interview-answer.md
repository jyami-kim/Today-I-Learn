### 1. 자바 기본타입 참조 타입 차이

primitive : 메모리에 값이 있는 것. (변수가 메모리에 있는 값을 가르킨다.) - 같은 값을 가지면 주소값 같습니다. (Stack 메모리 영역에 실제값을 저장)

reference : Object class를 상속 받는다. 기본형이 아닌경우 참조형 (객체를 만들고 메모리에서 그 객체의 위치를 갖고있음) - 같은 값을 가지더라도 주소값 다르고 (heap 메모리 영역에 객체를 확보하고 stack 메모리에는 주소값만 있다.)  



### 2. Exception

Checked exception : 코드단에서 처리해야하는 exception (compile error) - IOException : 코드상에서 무조껀 처리해줘야한다.

Unchecked exception : 예측이 가능한 exception (runtime error) - nullpointexception , indexoutofbound exception



### 3. springboot 차이





### 4. 데드락

리소스를 얻어야하는데, 얻지못하고 무한정 기다리는 상태 입니다.

A가 자원1을 갖고있고, B가 자원2를 갖고있는데, A는 자원2를 요청하고, B는 자원1을 요청할때 

- Mutual exclusion : 한번에 한 프로세스만 공유자원 사용
- hold and wait : 자신의 자원을 내놓지 않고, 다른 자원을 요구할 수 없다.
- no preemption : 다른 프로세스의 자원접근을 취소할 수 없다.
- circular wait : 프로세스 자원간 도식도에서 사이클이 존재





### 5. 쓰레드 세이프란?

쓰레드에서 사용해도 안전하다. 멀티쓰레드 + 동기화

두개 쓰레드 1개 자원에 대한 동시요청



### 6. TCP와 UDP의 차이점

TCP : 연결기반 - virtual path - packet - inorder - flow controller - 신뢰성이 - 속도가 느리다 - 헤더가 크다

URP : 목적지 기반 - port,ip 기반으로 전송 - 속도가 빠르다 - 헤더가 작다.



### 7. 스택, 큐, 퀵소트

스택 : first in last out

큐 : first in first out

퀵소트 : 공간 복잡도 O(n) / 시간복잡도 O(Nlogn) : pivot 선정 -> 기준보다 크면 왼쪽 작으면 오른쪽 -> 정렬될때까지 분할 처리 -> O(N^2)



### 9. 클러스터드 인덱스 / 논 클러스터드 인덱스



### 10. 파일시스템 / 데이터베이스의 차이점

파일시스템 : 데이터를 접근하고 조작하는 기능만 있다. - 데이터 불일치, 다수 사용자 불가능, 쉬운 질의어 없음, 보안기능 미흡

데이터베이스 : 파일 시스템의 단점을 개선하기 위한 것 - 데이터 일치, 다수 사용자 가능, 쉬운 질의어, 보안기능 있음.



### 11. 스프링 DI, IOC

**IOC**

사용자가 객체를 생성하고 소멸시키는걸 스프링 컨테이너가 대신 해준다.

제어권이 객체 자신이 아닌, 스프링에게 넘어갔기 때문에 IOC라고한다.  (프로그램 제어 흐름구조가 바뀐다.)

제어건이 스프링으로 넘어가서 DI를 해주게됩니다.

여러 객체를 bean 컨테이너로 관리한다 (bean은 object!!)



**DI**

인스턴스를 자신이 아닌 IOC 컨테이너에서 생성한 후에, 그 인스턴스를 주입합니다.

객체간 의존성을 내가 아니라 외부에서 주입하는 개념.

내부적으로는 new 키워드대신, contructer나 setter를 이용해서 주입합니다.

모듈간 결합도를 낮춘다.

mokito



##### AOP

관점지향 프로그래밍이다. 애플리케이션 전체에 걸쳐서 사용되는 기능을 재사용할 수 있게 하는 것이다.

각각의 핵심 기능인 서비스에서 바라봤을때는 공통된 요소가 없을 수 있지만, 부가기능이라는 관점에서보면 공통된 기능이 있을 수 있습니다.

예를들어 모든 서비스에서 트랜잭션이나, 로깅, 예외처리와 같이 공통적인 부분을 분리해서 관리하는 것을 의미한다. 

Aspect 를 이용해서 Before, After 메서드 실행 전 후 사용될 기능을 정의한다거나 하는 것을 알 수 있음.



### 12. Thread

한 프로세스를 여러개의 스레드로 구성하고, 각 스레드별로 하나의 작업을 처리한다.

- 설계, 디버깅 까다롭다. 테스트코드를 어떻게 짜지
- 동기화문제 발생 (자원 공유 문제) 
- 한개의 쓰레드 문제가 생기면 전체 프로세스 영향

구현 방법 : Thread 클래스 상속 or Runnable클래스 상속으로 run() 메소드 재정의



### 13. Map vs List

<https://gangnam-americano.tistory.com/41>

Set : 순서가 없다. 중복이 없다.

- HashSet : 가장 빠르다. 순서를 예측할 수 없다. : 데이터 유무 판단에 중점을 두었다.
- TreeSet : 정렬방법 지정이 된다. - 바이너리 서치트리의 형태로 정렬이 된다.

List: 순서 있다. 중복 있다. (특정 동일 공간에 뭉텅이로 저장한다)

- ArrayList : 단방향 포인터 구조, 인덱스가 있다. : 조회에 좋다. : : thread safe
- LinkedList : 양방향 포인터 구조, (스택, 큐, De큐에 사용된다.) 
- Vector : 어레이리스트 구조에 내부에서 자동 동기화 처리 : thread safe하지 않다.

Map 아이템 저장할 떄마다 빈공간을 찾는다.

- HashTable : 동기화를 지원한다
- HashMap : 동기화를 지원하지 않는다.
- TreeMap : 정렬된 순서대로 키 값을 지정해 검색이 빠르다

List : Memory안 특정 동일 공간에 뭉텅이 저장 : 데이터 저장속도 빠르다.

Map : 아이템을 저장할 때 마다 빈공간을 찾아 어장 : 데이터 저장속도 느리다. Entity를 이용한다.



### 14. Thread pool

스레드가 생성될때 : OS가 받아들여 메모리 확보하고, 메모리를 스레드에 할당 (이 비용!!!)

쓰레드를 미리 만들어두고, 필요할 때 하나씩 갖다 쓰는 것.



### 15. 테스트코드가 중요한 이유

기능에 대한 명세가 이루어진다.  = API DOC과 같은 것

project를 받자마자 API문서도 없는 상황에서 이해를 해야할 것 

기능을 BM에 맞게 수정했더니 다른 기능이 안되는 상황을 방지하기 위함



### 16. 유닛테스트와 통합테스트의 차이

유닛테스트

 - java pojo파일에 구현해둔 로직에 대한 테스트를 한다. 
 - 시간이 적게 걸린다.
 - 함수 하나하나와 같이 코드의 작은 부분을 테스트하는 것
 - string을 replace하는 작은 로직이라도 불확실성이 제거된다.
 - 디버깅 시간을 줄일 수 있다.



통합테스트

 - spring을 띄운다. POSTMAN으로도 가능하기는 하다.
 - 시간이 오래걸린다.





### 17. TDD 유닛테스트 차이

방식의 차이

TDD는 Test Driven Develop : 테스트를 먼저 만들고 테스트를 통과하지 위한 것을 짠다.

유닛테스트 : 구현을 먼저 짜고 테스트를 짠다.



### 18. 멀티쓰레드 vs 싱글쓰레드

싱글쓰레드 : 하나의 쓰레드로 두개의 작업을 하는 경우 : 한 작업이 마친 후 다른 작업을 시작

멀티쓰레드 : 두개의 쓰레드로 두개의 작업을 할 때 : 짧은 시간동안 2개의 쓰레드가 번갈아가면서 처리되서 동시에 두작업이 처리되는 것처럼 보인다.

수행시간은 같다.



간단 -> 싱글 쓰레드 good

자원공유가 많이 이루어지는 작업이면 멀티쓰레드가 효율적

네트워크로 데이터를 주고받는 작업 (멀티쓰레드) - 요청을 처리하는 네트워크 쪽 서버에 사용



### 19. WAS VS WebServer

Web Server Http를 통해 웹 브라우저에서 요청하는 html css image 파일등의 정적 컨텐츠를 전송해 주는 서버 (Nginx)

WAS : http를 통해 애플리케이션을 수행시켜주는 것 Webserver의 기능을 포함하고 있다. 동적으로 서버 컨텐츠를 수행한다. (Tomcat)



### 20. 트랜잭션 고립레벨

트랜잭션의 이상 읽기 현상

Dirty Read : A = 5로 update하고 커밋을 안했는데, 다른 트랜잭션이 이 값을 읽으면 잘못된 갓ㅂ이 나온다. (5로 읽는다.)

공유 lock을 걸어서, T1 처리동안 다른 트랜잭션 접근 못하게한다.

Non Repeatable Read : T1이 같은 쿼리를 두번 실행했는데 그 결과값이 다른경우 // T1이 select 2번했는데, T2가 그사이에 update delete 한 경우 

트랜잭션 완료때까지 수정 삭제를 제한한다.

Phantom Read

T1 트랜잭션은 같은 쿼리를 두번 실행했는데, 없던 레코드가 두번째에서 튀어나옴

트랜잭션 완료될가지 수정, 삭제, 삽입 불허한다.



Read Uncommited : D가능, NR 가능, P가능 [동시성이 커진다] : 커밋 안한걸 리드하는걸 허용한다.

Read Committed : D 불가능 , NR 가능, P가능 : 커밋한거만 리드하는걸 허용한다.

Repeatable Read : D불가능, NR불가능, P가능 : 트랜잭션이 종료될때까지 다른게 삽입하는거만 허한다.

Serializeable : D불가능, NRq불가능, P불가능 [병렬적으로 실행되지 못함 - 성능문제] : 모든걸 불허한다.



### 21. Nginx

아파치 : 요청하나당 쓰레드 하나가 처리 / 사용자 많으면 많은 쓰레드 생성 / 하나의 쓰레드 = 하나의 클라이언트

nginx : 비동기, 이벤트 드리븐 기반 / 다수의 연결을 효과적으로 처리 / 더작은 쓰레드로 클라이언트 요청 처리



nginx를 프록시 서버로 앞단에 두고, node.js를 뒤쪽에 두자. 보안적 부분을 처리할 수 있다.





### spring filter vs Interceptor

filter는 dispatcherservlet 앞에 있고, interceptor는 handler단인 controller 이젠에 있다.

- filter : 들어오는 url 자체를 거른다. url-pattern 등을 이용할 수 있다.

- interceptor: 세션에 대한 체크, 인증처리에서 사용한다 // filter와는 다르게 controller 전 후 과정이 있다.

  필터와는 다르게 분기가 명확하다. handlerMapper에서 이미 controller의 메서드를 찾아낸 이후에, 해당하는 controller 메서드 url에 대해 이미 등록된 interceptor와 매칭되는 것을 찾아낸후, preHandle => controller => postHandle 과정으로 수행된다.



### 프레임워크 vs 라이브러리

프레임워크는 라이브러리의 집함에 제어흐름의 주도성까지 갖고있는 것을 의미한다. 어플리케이션의 흐름을 프레임워크가 갖고있다. 사용자는 프레임워크의 흐름이 이용해서 코드를 짠다.

spring boot를 쓰다가, 내장된 라이브러리인 jedis의 버전이 3점대인게 싫어서, lettuce로 갈아끼우는 작업을 하는 것과

반면 라이브러리는 사용자가 전체적인 흐름을 만들고 라이브러리를 가져다 쓰는 것을 말한다. 애초에 lettuce를 사용하되, 그걸 어떻게 실행하고 어떻게 return하고를 사용자가 짜야하는 문제는 다르다.



### 캐싱

디비에서 읽기 전략은 join등 시간이 오래걸리는 경우가 많다.

왜냐하면 DB는 파일시스템에 데이터를 저장하는 것이기 때문에, 반면 캐시는 메모리에 있는 데이터를 읽어고고 저장하는 것이기 때문에 DB보다 훨씬 빠르다. 

따라서 나의 캐싱 전략은 DB에서 조회가 일어난 건수가 있다면 캐시에 저장을하고 유효시간을 정해둔다. 유효시간이 지나기 전에 같은 조회가 일어나면 캐시에서 데이터를 가져와서 좀더 빠르게 조회를 할 수 있다.



### JDBC 드라이버, 커넥션풀

#### JDBC 드라이버

java 내에서 DB와 관련된 작업들을 처리할 수 있도록 도와주는 일을 한다.

DB와의 통신에 필요한 API들의 구현체이다. 
DBMS별로 알맞는 JDBC드라이버가 필요하다.

com.mysql.jdbc.Driver 이런식으로 로드한다.

#### 커넥션 풀

커넥션 풀 : DB와 연결하는 커넥션들을 미리 생성해두고 풀에 저장해둔다. DB와 연결할 때 TCP 커넥션을 하기 때문에 연결에 걸리는 시간이 오래걸려, 성능을 위해 미리 풀에 저장해두는 것이다.

- DB connection 생성, 제거는 시스템에 부담을 주는 작업이다.ㄷ
- 연결 관리, 동시 Connection 들의 수를 설정하여, 그 이상으로 시도했을 때 DB에 부하를 주는 작업을 막는다.



### DB 격리레벨

##### read uncommited

각 트랜잭션에서 변경내용이 commit, rollback 상관없이 다른 트랜잭션에서 값을 읽을 수 있다.

commit이 되지 않은 상황이지만 update된 값을 다른 트랜잭션에서 값을 읽을 수 있다.

**(Dirty Read)** : 커밋되지 않고 종료되면 T2가 가진 데이터는 꼬인다.

> https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation>

##### read commited

RDB에서 대부분 이렇게 사용한다.

커밋이 완료된 데이터만 읽을 수 있다.

실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다. 

commit되기 이전과 이후에 읽었을 때 같은 결과가 아니다. (입출금에서 유의)

**(Non Repeatable Read)** : T1이 read하는데, 이때 다른 T2가 접근해서 값을 변경, 삭제하고 커밋하면 
T1이 해당 데이터를 read하고자하면, 변경된 혹은 사라진 데이터를 찾게된다.

##### repeatable read

트랜잭션 내에서 한번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다.

트랜잭션마다 트랜잭션 ID를 부여하여, 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽는다.

즉 읽기 트랜잭션이 10이고, 업데이트 트랜잭션이 12일때, 읽기 트랜잭션에서 여전히 10을 가지면 바뀐값을 읽지 않는다.

**(Phantom read)** :T1에서 특정 조건으로 데이터를 검색해서 결과를 얻음. 이때 T2가 접근해서 해당 조건의 데이터 일부를 삭제, 추가했을 때 아직 끝나지 않은 T1이 해당 조건으로 데이터를 조회하면, T2에서 추가 삭제된 데이터가 함께 조회 누락된다.

##### serializable

가장 엄격하게 처리한다. 그러나 동시 처리 성능이 급격히 떨어진다.



### DB ACID

- 원자성 : 한 트랜잭션은 한 작업
- 일관성 : 모든 트랜잭션은 일관적인 DB상태유지
- 격리성 : 동시에 실행되는 트랜잭션이 서로 영향주지 않게한다.
- 지속성 : 트랜잭션을 성공적으로 마치면 항상 저장된다.



### PK UK 차이

PK 

- 테이블에서 대표되는 key 
- 해당 컬럼은 unique하고 notnull 이어야한다
- Null 입력이 안된다.
- clustered index



UK

- 테이블에서 여러개를 생성할 수 있다.


- 테이블에서 해당 컬럼에 unique하다.
- non-clustered index



### clustered index nonclustered index

클러스터드 인덱스

- 테이블 당 한개만 생성이 가능하다.
- 행 데이터를 인덱스로 지정한 열에 맞춰서 자동 정렬한다. (index 대로 정렬)
- 인덱스를 생성할 때 데이터 페이지 전체를 다시 정렬한다. 성능이 좋다.



논클러스터드 인덱스

- 테이블당 여러개를 생성할 수 있다.
- leaf level의 인덱스 테이블이 새로 생긴다. : 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구현한다.



### DB 샤딩

같은 테이블 스키마를 가진 것을 여러 DB에 분산하여 저장하는 것

즉 정자동 주민테이블은 A DB에 서현동 주민테이블은 B DB에 저장되게 한다.

물리적으로 다른 데이터 베이스에 데이터를 수평분할 방식으로 분산 저장하고 조회하는 방법을 말한다.

인덱스 크기를 줄이고 작업 동시성을 늘리기 위함이다.

- 고스펙 컴퓨터 만들기
- Read 명령이 많으면 cache나 database replication 적용하기 
  (master, slave) : master는 insert update delete 수행 / slave는 select 수행
  slave는 master의 내용을 복사한다.



- algorithm sharding : DB ID로 단순히 나눈다 

- Dynamic sharding : 클라이언트가 locator에 접근해서 해당 key를 얻는다.

  locator에서는 해당 key의 range는 어느 디비에 들어가있고를 알 수 있다.



### 페이지 교체 알고리즘

- **LRU 알고리즘** - least recently used : 페이지 크기가 3이고, 0~4가 참조될 때, 가장 최근에 사용되지 않은 것을 지운다는 것입니다.
- **LFU 알고리즘** - least frequently used: 참조횟수가 가장 작은 페이지를 교체한다.
- **MFT 알고리즘** - most frequently used : 참조 횟수가 가장 많은 페이지를 교체한다.



### http2.0 vs http1.1

랜딩속도! 속도의 변화가 크게 생겨났다.

웹페이지의 리소스의 크기가 엄청 늘어났다. 그리고 웹페이지가 동적으로 작동된다.

http1이 느린 이유 : 앞에서 날린 요청의 응답을 받아야만 다음 요청이 처리될 수 있다.

- 1에서는 처음에 요청한 request에 문제가 있어서 응답이 늦어지면, 2번째 3번째 요청한 request의 응답도 같이 늦어진다.

이를 개선하고 싶었다

- 프로그래머는 서버는 같지만 도메인 명을 여러개 설정해서 이를 주소로 내려주면 다른 곳으로 요청을 보내는 것이기 때문에 여러개의 커넥션을 맺을 수 있다했다.

Multiplexing 개념이 도입되었다.

- 동시에 여러 리소스를 받아올 수 있게 되었다. 한 커넥션에서 여러 리소스를 동시에 받아올 수 있다.


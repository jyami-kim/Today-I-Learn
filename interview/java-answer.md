### 1. Java와 C/C++ 차이점

c : 컴파일 + 링크 / exe 파일등의 OS에 귀속된 실행파일

java : 컴파일 / 링크과정없이 컴파일러가 바이트코드를 생성함 / JVM에서 동작하여 OS에 종속적이 아니다. 

java가 class 라는 바이트코드를 생성을 하면 classloader가  클래스 파일들을 엮어서 JVM이 메모리에 할당받은 영역인 Runtme Data Area(자바 애플리케이션 실행시 사용되는 데이터를 적재한다.)에 배치시킨다.

Class Loader에 의해 메모리에 간 클래스들을 기계어로 Execution Engine이 변경하고 명령어 단위로 실행한다.



### 2. Java 언어의 장단점

[장점]

운영체제에 독립적 : JVM에서 작동해서 OS에 종속적이지 않다. 
( JVM에서)

객체지향적: 객체지향적으로 프로그래밍 함으로써 현실세계와 프로그래밍 언어 사이 격차를 줄일 수 있다/

자동으로 메모리 관리를 해준다 : JVM안에있는 GC덕분에 C와 다르게 malloc free 과정이 줄어든다.

오픈소스가 많다 : gradle maven depency만 봐도 엄청 많았습니다. 많은 라이브리를 사용했을 때 조금 더 짧은 개발 시간이 들었습니다.

[단점]

속도가 느리다 : 컴파일로 기계어가 만들어지는게 아니라 바이트코드가 만들어지고, JVM에서 바이트코드를 기계어로 번역하는 과정을 또 거치기 때문입니다.



### 3. Java의 접근 제어자

public : 어떤 클래스의 객체에서도 접근이 가능합니다.

private : 이 클래스에서 생성된 객체들만 접근이 가능합니다.

protected : 같은 패키지 폴더안에 있거나 상속관계에 있는 객체들만 접근이 가능합니다.

default : 같은 패키지 폴더안에 있는 객체만 접근이 가능합니다.



### 4. OOP 네가지 특징

추상화.(Abstraction): 사물의 공통된 특징을 파악해서 하나의 집합으로 묶는걸 의미합니다.

현실세계의 것 -> 프로그래밍 적으로 구현하기 위해 필요

사이다 / 포카리 스웨트 / 코카콜라  -> 음료수 



캡슐화 (Encaptualation): 정보 은닉개념 : 필요없는 정보는 외부에서 접근하지 못하게

높은 응집도와 낮은 결합도를 갖추기 위해서 입니다 = 클래스간 의존을 줄인다는 것.
Domin 개념과 밀접하다. 

ex ) 만약 public으로 열어놔서 Company객체에서 People객체의 내용을 바꿀 수 있는 경우
​	따라서 this 객체의 내용은 this 객체만 바꿀 수 있게 유도하는 개념



일반화 (Generalization): 부모와 자식의 개념 즉 상속관계!! (캡슐화 일종) 

Collections  > List<> : ArrayList LickedList

네이버 에디터 product > 동영상에디터, 포토에디터, 텍스트 에디터



다형성 (Polymorphism): 서로다른 클래스의 객체가 같은 메세지를 받았을 때 각자의 방식으로 동작하는 능력(여러가지 형태를 가지는 능력) 

helloworld : 객체의 책임, 역할에 따라서 출력, 저장, 출력을 하는데 lowercase적용 [오버라이딩, 오버로딩]

Parent p = new Childe();

Parent p = new Parent();

upcasting

instanceof() : equals에서 많이 사용된다!



### 5. OOP 5대원칙 (SOLID)

S : 단일 책임원칙 (SRP) - 객체는 한개의 책임

요구사항의 변경이 있을 때 영향받는 부분을 줄임 : ResponseMessage.class (그때그때 만들지 않음)

OCP에서는 확장에 필요한 행위(영역)를 Abstraction함. (메모리를 read, write해야되는 행위를 abstraction)

rectangle 클래스가 직사각형 모형의 넓이를 제공하는것, 그리고 그리는 것을 제공한다면 단일 책임의 원칙을 위반하는 것이다



O.: 개방 폐쇄 원칙 (OCP)

기존의 코드를 변경하지 않으면서 기능을 추가할 수 있게 해야한다.

확장은 열려있고, 변경은 닫혀있다. // 변경을 최소화하자!! - 확장을 

switch는 light를 키고 끄고 하는걸 구현해야함. : 이때 light가 언제든지 바뀔 수 있음. (interface를 잘 활용한다.)



L : 리스코프 치환원칙 (LSP)

자식클래스는 최소한 부모클래스의 기능은 동작해야한다.

Point x y // ColorPoint x y z 

이때 Point와 ColorPoint는 다르다고 해버린다. 그러면 그게 옳은가? 옳지 않다!!

Point의 하위클래스인 ColorPoint는 여전히 Point임 따라서 Point끼리 비교하는데 어디서든 Point로 활용이 가능해야함



I : 인터페이스 분리원칙 (ISP)

인터페이스를 클라이언트에 특화되도록한다. 

- 자신이 이용하지 않는 기능에 영향받지 않게 해야함.
- 인터페이스를 만들고 그 내부구현을 갈아끼울 수 있게 한다면 인터페이스에서 정의한기능은 동작함.

프린터 클라이언트 - 프린터 인터페이스 - 복합기

복사 클라이언트 - 프린터 인터페이스 - 복합기

light의 의존성을 줄여야한다. > 인터페이스를 사용한다 :: 강한 연결을 뺀다

가장 큰 문제는 이렇게 의존성이 연결되어있는 객체를 클라이언트에 노출함. 근데 이 key를 light가 아니라 brightlight라고 하면 요구사항에서의 변경이 있을 때 영향받는 부분이 생길수밖에..



D : 의존 역전원칙 (DIP : dependency inversion principle)

자신보다 변하기 쉬운 것에 의존하지 말라
구체적인 것이 추상화된 것에 의존해야한다

의존 관계를 맺을 때 변화하기 쉬운 것(클래스)보단 변화하기 어려운것(인터페이스, 상위클래스, 추상클래스)에 의존하라.



DI : 의존성 주입 (클래스 외부의 것을 객체의 인스턴스 변수에 주입하여 의존관계가 생기게 한다.)

Main에서 의존성 주입을 해줌 : Kid와 Toy 객체가 있을 때 Kid.play(Toy) 이런식으로!

DIP에서는 로우 레벨에 의존성을 갖는 부분을 Abstraction 함.



### 6. 객체지향 프로그래밍 vs 절차지향 프로그래밍

절차지향 : 일의 흐름에 중점 (순차적) (알고리즘)

객체지향 : 물체를 하나의 객체로 표현한다. 현실세계의 것을 추상화하여 객체간의 상호작용을 프로그래밍으로!

그룹화하는게 핵심이며 객체지향이 나온 이유는 협업이 쉬워지기 때문이다. (프로젝트)



### 7. Non-static vs static

Non-static-member : 객체마다 하나 : 객체가 생겨야 사용가능하다. : 공유하지 않는다.

static-member : 클래스마다 하나. 객체가 생기기전에 생성된다. : 공유한다



### 8. java의 final

변수, 메서드, 클래스가 변경불가능하게!

primitive : 값변경 X

reference : 참조 변수가 heap내의 다른 객체 가리키게 못한다.

method : 오버라이드 불가

class : 하위클래스 정의 불가



### 9. GC 처리방법

가비지컬렉터 : JVM내 heap 영역에서 사용중인 객체들 중에, 사용되는 것과 아닌것을 구별하여 메모리를 해제하고 메모리 해제를 대신 해줍니다. 

마크앤 스윕 과정이 있는데

이때 GC는 참조되고 있는객체와 참조되지 않은 객체를 마크해서 GC대상을 선별한다.

그리고 선별된 객체를 스윕 삭제한다.

이렇게 되면 메모리에서는 구멍이 뚫린 것처럼 중간중간 해제가 된 부분이 있는데, 이것들을 메모리 앞으로 재정렬 하는 과정이 필요하다 이것을 compact라한다.

이 컴팩트 과정이 일어날 때는 메모리를 재할당 하는 과정이 필요하기 때문에 GC를 처리하는 쓰레드 말고 다른 스레드를 전부 멈추게 한 다음 메모리를 해제한다.

GC를 실행하면 GC 스레드만 살고, 다른 스레드는 멈춘 후에 메모리를 해제하는데 이 과정을 Stop The World라고 한다.



### 10. 객체 직렬화 역질렬화

직렬화 : 객체를 전송가능한 형태로 만드는것 (stream 데이터)

> 직렬화 가능하게 Serializable 상속

역직렬화 : 직렬화된 파일을 역으로 직력화하여 다시 객체의 형태로 만드는 것 (stream 데이터)



### 11. 클래스, 객체, 인스턴스

Animal a = New Animal()

클래스 : 객체를 만들기 위한 설계도

객체 : 구현 대상 (실제 메모리가 잡힌 것)

인스턴스 : 



### 12. 오버로딩 vs 오버라이딩

오버로딩 : 두메서드이름이 같은데 파라미터수 자료형이 다름 > 컴파일단에서 타입체크

오버라이딩 : 두 메서드의 이름, 파라미터수, 자료형 모두 같은데 구현 방식이 다름 (상속관계에서 이루어짐.) > 런타임 단에서 타입 체크



### 13. Call by Reference VS Call by Value

Call by value 값에 의한 호출

함수 호출에서 변수의 값을 복사하여 함수의 인자로 전달한다. 이때 함수안에서 값을 수정해도 함수 밖에서 할당한 변수값은 변경되지 않는다.

call by reference 참조에 의한 호출

함수 호출에서 참조 값을 복사하여 함수의 인자로 전달한다. 이때 함수 안에서 값이 수정되면 인자로 전달된 값도 변경된다.



### 14. interface VS abstract Class

추상 클래스 / 인터페이스

인스턴스는 생성할 수 없다. 선언만 있다.

추상클래스 : 단일 상속 (kind of) : 추상 메서드를 자식이 구체화 하기 - 기능 확장 (기능확장)

인터페이스 : 다중 상속 (can do this) : 여러 클래스에서 공통적으로 필요할 때 사용 (동일 동작의 약속)



### 15. Collections

Map : hashMap (hashcode 사용) - 비동기 처리

Collection - Set ) HashSet - 해시 알고리즘

Collection - List ) LinkedList(양방향 - 삽입 삭제가 빈번할 때) ArrayList(단방향 - 삽입 삭제 부적합)



### 16. String StringBuilder StringBuffer

String : ++ 방식이 치명적이다. private final char[] 형태로 불변 클래스이다. 새로운 값 할당할 때 클래스에 대한 객체가 생성된다. 

StringBuilder, StringBuffer = memory에 append하는 방식이다. Builder(비동기) / Buffer(동기)



### 17. 동기화 비동기화 차이

동기 : 요청과 결과가 동시에 일어난다. (trasaction을 동시에 맞춘다.)

계좌요청 : A의계좌 빼기 -> B계좌 늘리기 -> 확인 -> 서로 처리

비동기 : 요청과 결과가 동시 이루어지지 않는다. (transaction을 동시에 맞추지 않는다.)

학생 공부해서 시험지 넘기기 -> 선생 채점 -> 시험결과 확인

논블록 블록

학생이 시험지 선생에게 건낸후 아무것도 못한다 (블록)

학생이 시험지를 선생에게 건내고 다른일 한다. (논블록)



### 18. java의 ==과 equals() 차이

primitive 타입이든 reference 타입이든 equals는 논리적 동치성 비교를 한다.

== 는 주소값을 비교한다. (이때 primitive타입은 값을 가르키기 때문에 주소값이 같다는건 값이 같다는걸 보장한다.)



### 19. java reflection

클래스와 멤버 필드에 대한 정보를 알 수 있다.

private Member 라는 클래스가 있을때

Class 클래스, Method 클래스를 이용해서 클래스의 이름값, Method Field의 이름값 등을 넣을 수도 있고, 새로운 인스턴스를 만들 수도 있다.



### 20. 자바를 만든 사람

제임스 고슬링



### 21. collection에서 제네릭을 사용하는 이유

컬렉션에서 특정 타입만 포함할 수 있게 제네릭을 제한한다. List Integer에 Boolean이 들어가지 않도록

제네릭으로 제한을 함으로써 런타임에 발생할 수 있는 Type에러를 컴파일타임에 잡을 수 있다.



### 22. Wrapper class

Primitive type을 reference type으로 만들어야할 경우에 사용한다.

참조자료형을 사용하면 Null 을 가질 수 있고, 객체간 비교가 가능하다.



### 23. Java EE와 SE의 차이점

SE = Java Platform Standard Edition : 데스크톱, 서버, 임베디드를 위한 표준 자바 플랫폼 (안드로이드)

EE = Java Platform EnterPrise Edition : 자바를 이용한 서버측 개발을 위함



### 24. 변수

하나의 값을 저장할 수 있는 메모리 공간



### 25. 자바의 메모리 영역(Runtime Data Area)

1. 메서드 영역  : 클래스 멤버변수, 데이터 타입, 접근제어자, 리턴타입 변수등이 생성된다. (String은 메서드 영역에 저장 - final class라서)
2. 스택 : 지역변수, 파라미터 등 임시 값들이 생성된다.
3. 힙 : new Keyword로 생성된 객체와 배열이 생성되는 영역이다.
4. PC Register : Thread 생성될 때 마다 쓰레드가 실행되는 부분의 주소를 명시한다.
5. Native method stack : 자바외 언어로 작성된 네이티브 코드

Person p = new Persion // Person p 는 스택영역에 생산 / new Person 자체는 힙에 생성



### 26. 쿠키 + 세션

쿠키 세션 모두 사용자의 데이터를 저장

쿠키 : 클라이언트 컴퓨터에 저장했다가 서버요청시 네트워크를 타고 서버에 전달 (사용자 검색기록을 서치 가능)

세션 : 서버에 저장되고 브라우저 단위로 관리된다.



### 27. REST FUL

url만 보더라도 무슨 작업을 하는지 알 수 있게 한다. 하나의 URL로 creat인지 update인지 알게함.

HTTP URI을 이용해서 자원을 명시하고, HTTP Method를 통해 해당 자원에 대한 CRUD operation을 적용하는 것이다.

- Head : header정보 조회

json, xml을 이용해서 데이터를 주고받는 것이 일반적이다.

Http 프로토콜은 stateless protocol이라서 rest역시 stateless하다. 서버는 각각의 요청을 완전히 별개의 것으로 인식하고 처리한다.

``-`` 을 사용한다.

URL 경로에는 소문자를 사용한다

파일 확장자는 URI에 포함하지 않는다.

REST API를 제공하는 웹서비스 : 이해하기 쉬운 REST API를 만든다.



### 28. Database index

table에 대한 동작 속도를 높여주는 자료구조로 빠른 검색을 가능하게 해준다.



### 29. 제네릭

클래스 내부에서 사용할 데이터타입을 인스턴스 생성할 때 결정하는 방식이다.



1. 흥미
2. 네이버 인턴 > 어려웠던 일 어떻게 해결했는지

멀티쓰레드 어려움 / 쓰는이유

1. 알고리즘 수업들었을 때 기억나는 것
### Item 15 : 클래스와 멤버의 접근 권한을 최소화하라

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라.

- 꼭 필요한 것만 골라 최소한의 public API를 설계하자.

- 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야한다.

- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다.

- public static final 필드가 참조하는 객체가 불변인지 확인하라

  ​



### Item 16 : public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

- public 클래스는 절대 가변 필드를 직접 노출해서는 안된다.
- 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.
- 하지만 package-private 클래스나 private 중청 클래스에서는 종종 (불변이든 가변이든) 필드를 노출하는 편이 나을 때도 있다.



### Item 17 : 변경 가능성을 최소화하라

- 클래스가 꼭 필요한 경우가 아니면 불변이어야 한다. (getter가 있다고 해서 setter를 무조껀 만들지는 말자)
- 무거운 값객체의 경우 성능때문에 어쩔수 없다면, 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하자.
  *[아이템 67] 최적화는 신중히 하라*
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자
- 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야한다. 



### Item 18 : 상속보다는 컴포지션을 사용하라

- 상속은 강력하지만 캡슐화를 해친다는 문제가 잇다.
- 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야한다.
- is-a 관계이여도 하위클래스의 패키지가 상위 클래스와 다르고, 상위클래스가 확장을 고려해 설계되지 않으면 문제가 될 수 있다.
- 상속의 취약점을 피하려면 상속대신 컴포지션과 전달을 사용하자. (특히 래퍼 클래스로 구현할 적당한 인터페이스가 있따면 더욱 그렇다)
- 래퍼클래스는 하위클래스보다 견고하고 강력하다.




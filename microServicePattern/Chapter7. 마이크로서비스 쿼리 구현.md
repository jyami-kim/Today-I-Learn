# Chapter7. 마이크로서비스 쿼리 구현

### 1) API 조합 패턴 응용 쿼리



#### 7.1.2. API 조합 패턴 개요

데이터를 가진 서비스를 호출한 후 그 반환 결과를 조합해서 가져온다.

- API 조합기 : 프로바이더(provider) 서비스를 쿼리하여 데이터를 조회함
- 프로바이더 서비스 : 최종 결과로 반환할 데이터의 일부를 갖고있는 서비스

API 조합기 : 클라이언트 / API 게이트웨이 / 프런트를 위한 백엔드 패턴의 변형(variant)

인-메모리 조인 : 조인 대상이 되는 두 테이블에서 공통적으로 존재하는 컬럼의 값이 일치되는 행을 연결하여 결과를 생성하는 조인 기법





#### 7.1.4. API 조합 설계 이슈

누가 API 조합기 역할을 맡을 것인가

- 서비스 클라이언트 (ex. 웹 어플리케이션) : 동일한 LAN에서 실행 중이면 가장 효율적 / 그러나 방화벽 외부이고 네트워크 느리면 비효율
-  API 게이트웨이
- API 조합기를 스탠드 얼론 서비스로 구현 : 내부적으로 여러 서비스가 사용하는 쿼리작업일 떄 좋음

API 조합기는 리액티브 프로그래밍 모델을 사용해야한다.



#### 7.1.5. API 조합 패턴의 단점

- 오버헤드 증가
- 가용성 저하 우려
  - 높이는 전략 1 ) 프로바이더 서비스가 불능일 때 API 조합기가 이전에 캐시한 데이터를 반환
  - 높이는 전략 2 ) API 조합기가 미완성된 데이터를 반환하는 것
- 데이서 일관성 결여



### 2) CQRS 패턴

커맨드 쿼리 책임 분리 : 여러 서비스에 있는 데이터를 가져오는 쿼리는 이벤트를 이용하여 해당 서비스의 데이터를 복제한 읽기 전용 뷰를 유지한다.

하나 이상의 쿼리가 구현된 하나 이상의 뷰 DB를 유지하는 기법



#### 7.2.2. CQRS 개요

MSA에서 쿼리 구현시 난관 세가지

- API 조합해 데이터 조회하려면 비효율적인 인-메모리 조인을 해야함
- 데이터를 가진 서비스는 필요한 쿼리를 효율적으로 지원하지 않는 DB에 저장
- 관심사를 분리할 피룡가 있다는건, 데이터를 가진 서비스가 쿼리 작업을 구현할 장소로 적합하지 않다

이걸 CQRS로 해결이 가능하다



##### CQRS는 커맨드와 쿼리를 서로 분리한다

관심사의 분리/ 구분에 대한 패턴임.

- 조회기능 : 쿼리쪽 모듈 및 데이터 모델에 구현
- 생성/수정/삭제 기능 : 커맨드 쪽 모듈 및 데이터 모델에 구현

![image-20210303213350503](/Users/kakao/Library/Application Support/typora-user-images/image-20210303213350503.png)

비 CQRS

- 보통 DB에 매핑된 도메인 모델로 구현
- 성능이 중요하면 직접 DB에 접속하기도함

CQRS

- 커맨드쪽 도메인모델은 CRUD 작업을 처리하고 자체 DB에 매핑

  외부에는 R을 제공하지 않지만 내부적으로 기본키 기반의 조인없는 단순쿼리정도는 R 작업을 할 수 있음

- 별도로 나누어진 쿼리모델은 다소 복잡한 쿼리를 처리함. 쿼리쪽에는 도메인 이벤트를 구독하고 DB를 업데이트하는 이벤트 핸들러가 있다



##### CQRS와 쿼리 전용 서비스

- 커맨드 작업이 전혀 없는 오직 쿼리 작업으로 구성된 API
- 다른 서비스가 발행한 이벤트를 구독하여 항상 최신 상태로 유지되는 DB를 쿼리하는 로직 > 뷰DB를 업데이트함



#### 7.2.3. CQRS의 장점

- 마이크로 서비스 아키텍처에서 효율적인 쿼리가 가능하다
- 다양한 쿼리를 효율적으로 구현할 수 있다
- 이벤트 소싱 애플리케이션에서 쿼리가 가능하다
- 관심사가 더 분리된다



#### 7.2.4. CQRS의 단점

- 아키텍처가 복잡하다
- 복제 시차(replication lag)를 처리해야 한다



### 3) CQRS 뷰 설계

#### 7.3.1. 뷰 DB 선택

##### SQL대 NoSQL DB

NoSQL DB는 CQRS 뷰와 잘 맞는 편이다. 

1) 풍성한 데이터모델, 우수한 성능
2) 단순 트랜잭션만 사용하고 고정된 쿼리만 실행하므로



##### 업데이트 작업 지원

이벤트 핸들러는 대개 뷰 DB에 있는 레코드를 기본키로 찾아 수정/삭제 함

NoSQL 비 기본피 기반 업데이트 쉽지 않음 > 보조 인덱스



#### 7.3.2. 데이터 접근 모듈 설계

DB에 직접 접근하지 않음 : 데이터 접근 객체 및 헬퍼클래스로 구성된 데이터 접근모듈을 사용한다

##### 동시성 처리

동시 업데이트로 서로 데이터를 덮어 쓰지 않게 작성되어ㅣ야한다.

DAO가 레코드를 읽고 업데이트된 레코드를 쓴다면 낙관적 잠금이든, 비관적 잠금이든 둘중 하나를 적용해야함



##### 멱등한 이벤트 핸들러

이벤트 핸들러가 중복 이벤트를 알아서 솎아내면 괜찮을 것

비 멱등적 이벤트 핸들러는 처리한 이벤트 ID를 기록해 두었다가 중복 이벤트가 들어오면 솎아내야한다.



##### 클라이언트 애플리케이션이 최종 일관된 뷰를 사용할 수 있다

커맨드 쿼리 모듈을 사용하면 클라이언트가 비일관성을 감지하게 만들 수 있음

1. 커맨드쪽 작업이 완료되면 클라이언트에 이벤트의 ID가 포함된 토큰을 반환함
2. 클라이언트가 쿼리를 토큰과 함께 전달하면 비 일관성 감지가 가능함 > 이벤트ID가 유효하지 않으면 에러가 반환



#### 7.3.3. CQRS 뷰 추가 업데이트

##### 아카이빙된 이벤트를 이용해 CQRS 뷰 구축

메시지 브로커는 메시지를 무기한 보관할 수 없다. > 영구적으로 보관하지 않음.

더 오래된 이벤트를 가져오고 싶다면 AWS S3와 같은 아카이빙된 다른 빅데이터 기술을 응용한다



##### CQRS 뷰를 단계적으로 구축

시간/리소스가 점점 증가하는 것도 뷰 생성의 또 다른 문제점 > 2단계 증분 알고리즘

1단계 : 주기적으로 애그리거트 인스턴스의 스냅샷을 찍고, 그 이전과 이 스냅샷이 생성된 이후 죽 발생한 이벤트를 바탕으로 계산 

2단계 : 계산된 스냅샷과 그 이후 발생한 이벤트를 이용해 뷰를 생성


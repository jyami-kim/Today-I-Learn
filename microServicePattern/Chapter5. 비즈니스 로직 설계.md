# Chapter 5. 비즈니스 로직 설계

### 1) 비즈니스 로직 구성 패턴



#### 5.1.1. 트랜잭션 스크립트 패턴

- 동작이 구현된 클래스와 상태를 보관하는 클래스가 따로 존재
- 비즈니스 로직을 요청 타입별로 하나씩 매핑된 절차적 트랜잭션 스크립트 뭉치로 구성한다.



#### 5.1.2. 도메인 모델 패턴

- 비즈니스 로직을 상태와 동작을 가진 클래스로 구성된 객체 모델로 구성
- 상태/동작 모두 가지고있다.
- 상태는 모두 메서드(동작)를 통한 간접 접근만 가능하다
- 표현층 > 응용층 > 도메인층 > 인프라층

##### 장점

- 설계 이해 관리가 쉽다.
- 객체지향 설계는 테스트가 쉽다
- 잘 알려진 설계 패턴을 응용할 수 있기 때문에 확장에 쉽다



#### 5.1.3. 도메인 주도 설계 개요

DDD 방식 설계 : 각 서비스는 자체 도메인 모델을 가지며, 애플리케이션 전체 도메인 모델(application-wide domain model)의 문제점을 방지할 수 있다.

- 엔터티(entity) : 두 속성값이 동일해도 다른 객체 (식별자 O)
- 밸류객체(value object) : 여러 값을 모아놓은 객체 (식별자 X)
- 팩토리(factory) : 복잡한 객체 생성 로직이 구현되어있음
- 리포지터리(repository) : DB접근 로직
- 서비스(service) : 비즈니스 로직 구현



### 2) 도메인 모델 설계 : DDD 애그리거트 패턴

불분명한 경계가 있으면 비즈니스객체 업데이트할 때 문제가 생길 수 있다.



#### 5.2.2. 애그리거트는 경계가 분명하다

애그리거트 : 한 단위로 취급 가능한 경계 내부의 도메인 객체
 = 1개의 루트 엔터티 + N개의 기타 엔터티 + N개의 밸류 객체

도메인 모델은 여러 애그리거트로 구성한다. 한 단위로 취급 가능한 객체망

루트 애그리거트끼리만 통신을 한다.



##### 애그리게이터 경계

일부가 아니라 전체 애그리거트를 업데이트해서 일관성 문제가 해소된다.



##### 애그리거트 식별

DDD 도메인 모델 설계의 핵심은 애그리거트와 그 경계, 그리고 루트를 식별하는 것



#### 5.2.3. 애그리거트 규칙

##### #1 : 애그리거트 루트만 참조

외부 클래스는 반드시 애그리거트의 루트 엔터티만 참조할 수 있게 제한

##### #2 : 애그리거트 간 참조는 반드시 기본키 사용

객체 레퍼런스 대신에 신원(ex. 기본키)을 사용 > 느슨하게 결합 된다

애그리거트는 그 자체가 저장단위임 (저장 로직 간단)

##### #3 : 하나의 트랜잭션으로 하나의 애그리거트를 생성/수정

MSA 아키텍처와 잘 맞아떨어짐

NoSQL DB 제한된 트랜잭션 모델과도 잘 어울림



#### 5.2.4. 애그리거트 입도

애그리거트는 가급적 잘게 나누는 것이 최선이다



#### 5.2.5. 비즈니스 로직 설계 : 애그리거트

비즈니스 로직 = Order 애그리거트 + OrderService + OrderRepository + N개의 사가



### 3) 도메인 이벤트 발행

도메인 이벤드 : 애그리거트에 발생한 사건 / 도메인 모델에서는 클래스로 표현, 대부분 어떤 상태 변경을 나타냄



#### 5.3.1. 변경이벤트 발행 이유

다른 구성원(사용자, 다른 애플리케이션, 같은 애플리케이션 내 다른 컴포넌트)들이 에그리거트 상태 변경을 궁금해 함



#### 5.3.2. 도메인 이벤트

이벤트에 의미를 부여하는 프로퍼티

이벤트ID / 타임스탭프 같은 메타데이터도 있다.



#### 5.3.3. 이벤트 강화 (event enrichment)

이벤트 컨슈머가 이벤트를 받아 처리하려면 주문내역이 필요함.
다른 곳에 쿼리해서 데이터를 가져오지 않게함

컨슈머에 필요한 정보를 이벤트가 갖고다닌다.



#### 5.3.4. 도메인 이벤트 식별

이벤트 스토밍 (event storming) : 복잡한 도메인 이해를 위해 이벤트 중심 워크숍을 하는 것



#### 5.3.5. 도메인 이벤트 생성 및 발행

##### 도메인 이벤트 생성

도메인 이벤트는 애그리거트가 발행함

애그리거트와 호출하는 서비스의 책임을 분리하는게 좋음

서비스는 애그리거트 루트 메서드를 호출한 후 이벤트를 발행함 : TicketService는, Ticket의 accept를 호출 한 후에 나오는 TicketDomainEvent를 publish 한다



#### 5.3.6. 도메인 이벤트 소비

도메인 이벤트는 결국 메시지로 바뀌어 아파치 카프카 같은 메시지 브로커에 발행된다.

이 브로커에 있는 이벤트를를 구독하는 컨슈머




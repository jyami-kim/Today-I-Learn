# Chapter 4. 트랜잭션관리 - 사가

### 1) 마이크로서비스 아키텍처에서의 트랜잭션 관리

#### 4.1.1. 분산 트랜잭션의 필요성

서비스마다 DB가 따로있어서 여러 DB에 걸쳐 데이터 일관성을 유지할 수 있는 수간을 강구해야함



#### 4.1.2. 분산 트랜잭션의 문제점

X/Open DTP 모델 (X/Open XA) : 분산 트랜잭션 관리의 사실상 표준
2단계 커밋(2PC)을 이용

- NoSQL, 현대 메시지 브로커는 분산 트랜잭션을 지원하지 않는다
- 동기 IPC 형태라 가용성이 떨어진다 (참여한 서비스가 모두 가동중이어야 커밋가능)
- CAP 정리 : 시스템은 일관성(consistency), 가용성(availability), 분할 허용성(partition tolerance) 중 두개 속성만 가질 수 있다. (일관성보다 가용성 더 우선시)



#### 4.1.3. 데이터 일관성 유지 : 사가패턴

사가 : 마이크로서비스 아키텍처에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 매커니즘

- ACID 트랜잭션의 격리성(I)이 사가에는 없다
- 사가는 로컬 트랜잭션마다 변경분을 커밋해서 보상 트랜잭션을 걸어 롤백한다

서비스는 로컬 트랜잭션이 완료되면 메시지를 발행해 다음 사가 단계를 트리거함



##### 사가의 보상 트랜잭션

사가 : 단계마다 로컬 DB에 변경분 커밋을해서 자동 롤백은 불가능

보상 트랜잭션(compensating transaction)
T(n+1)에서 실패하면 T1, ... , Tn을 언두하고, Cn, ..., C1을 순서대로 실행
Ci와 Ti는 순서화(sequencing) 원리가 동일해서 Ci가 끝나면 Ci+1 실행이 트리거된다

- 보상 트랜잭션 (compensating transaction ) : 실패할 가능성이 있는 단계 다음에 있음
- 피봇 트랜잭션 (pivot transaction) : 절대로 실패하지 않는 단계 다음에 있음
- 재시도 가능 트랜잭션 (retriable transaction) : 항상 성공



### 2) 사가 편성

도중 하나라도 로컬 트랜잭션이 실패하면 사가는 보상 트랜잭션을 역순으로 실행함

##### 사가 편성 로직 두가지

- 코레오그래피(choreography) : 의사 결정과 순서화를 사가 참여자에게 맡김 - 이벤트 교환 방식으로 통신
- 오케스트레이션(orchestration) : 사가 오케스트레이터에 중앙화 - 오케스트레이터가 사가 참여자에게 커멘드 메시지를 보내 수행할 작업 지시



#### 4.2.1. 코레오그래피 사가

사가 참여자가 서로 이벤트를 구독해서 그에 따라 반응

- 사가 참여자가 자신의 DB를 업데이트하고, DB 트랜잭션의 일부로 이벤트를 방행하게 해야한다
  DB업데이트 작업과 이벤트 발생 작업이 원자적(atomically)으로 일어나야함
- 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관지을 수 있어야함



##### 코레오그래피 사가의 장점

- 단순함
- 느슨한 결합

##### 코레오그래피 사가의 단점

- 이해하기 어렵다
- 서비스 간 순환 의존성
- 단단히 결합될 위험성



#### 4.2.2. 오케스트레이션 사가

오케스트레이터 클래스(orchestrator class) : 사가 참여자가 할 일을 알려줌

사가 오케스트레이터는 상태기계로 모델링이 가능하다. 

상태기계(state machine) = 상태(state) + 상태 전이(transaction)

- 상태 전이(transaction) : 이벤트에 의해 트리거
- 액션(action) : 전이 발생할 때 마다 일어남. 사가 참여자를 호출하는 작용



##### 오케스트레이션 사가의 장점

- 의존 관계 단순화 : 순환 의존성 발생하지 않음
- 낮은 결합도
- 관심사를 더 분리하고 비즈니스 로직을 단순화

##### 오케스트레이션 사가의 단점

비즈니스 로직을 오케스트레이터에 너무 많이 중앙화하면 똑똑한 오케스트레이터 하나가 깡통서비스에 일일이 할 일을 지시하는 모양새가 될 수도 있다.



### 3) 비격리 문제 처리

AICD의 격리성(I) : 동시에 실행 중인 여러 트랜잭션의 결과가 어떤 순서대로 실행된 결과와 동일함을 보장하는 속성

- 한 사가가 실행 중에 접근하는 데이터를 도중에 다른 사가가 바꿔치기 할 수 있음
- 한 사가가 업데이트를 하기 이전 데이터를 다른 사가가 읽을 수 있어서 데이터 일관성이 깨질 수 있음

사실상 ACD 트랜잭션으로 봐야한다



#### 4.3.1. 비정상 개요

- 소실된 업데이트(lost updates)
- 더티 읽기(dirty reads)
- 퍼지/반복 불가능한 읽기(fuzzy/nonrepeatable reads)



##### 소실된 업데이트

한 사가의 변경분을 다른 사가가 덮어 쓸 때

##### 더티 읽기

한 사가가 업데이트 중인 데이터를 다른 사가가 읽을 때 발생한다 



#### 4.3.2. 비격리 대책

*_PENDING 상태도 이상 현상을 예방하는 전략중 하나이다.

- 시맨틱 락 (semantic lock) : 보상 가능 트랜잭션이 생성/수정하는 레코드에 무조건 플래그를 세팅하는 대책
- 교환적 업데이트 (commutative updates) : 어떤 순서로도 실행가능하게 설계
- 비관적 관점 (pessimistic view) : 더티 읽기로 인한 비즈니스 리스크를 최소화 하기 위해 사가 단계의 순서를 재조정
- 값 다시 읽기 (reread value) : 사가가 레코드를 업데이트 하기 전에 값을 다시 읽어 값이 변경되지 않았는지 확인하는 것
- 버전 파일 (version file) : 레코드에 수행한 작업을 하나하나 기록하는 대책 (비교환적 (noncommutative)작업을 교환적(commutative) 작업으로 변환하는 방법)
- 값에 의한 (by value) : 비즈니스 위험성을 기준으로 동시성 메커니즘 선택
  위험성이 큰 요청은 분산 트랜잭션 / 낮은 요청은 사가


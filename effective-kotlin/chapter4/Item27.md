# Item27. 변화로부터 코드를 보호하려면 추상화를 사용하라

### 상수

리터럴을 상수 프로퍼티로 추출할 때

- 이름을 붙일 수 있다.
- 나중에 해당 값을 쉽게 변경할 수 있다.



### 함수

- 함수는 추상화를 표현하는 수단.
- 함수 시그니처는 이 함수가 어떤 추상화를 표현하고 있는지 알려준다 : 의미 있는 이름이 중요하다.
- 함수는 상태를 유지하지 않는다.
- 함수 시그니처를 변경하면 프로그램 전체에 큰 영향을 줄 수 있다.



### 클래스

- 클래스가 함수보다 더 강력한 추상화를 한다.
- 상태를 가질 수 있다, 많은 함수를 가질 수 있다.
- 클래스가 좀 더 많은 자유를 보장해준다.
  - 의존성 주입 프레임워크를 사용하면, 클래스 생성을 위임할 수도 있다.
  - mock을 이용해서 해당 클래스에 의존하는 다른 클래스의 기능을 테스트할 수 있다.
  - 메시지를 출력하는 더 다양한 종류의 메서드를 만들 수도 있다.



### 인터페이스

인터페이스를 이용해 더 추상적이게 만들 수 있다.

코틀린 표준 라이브러리를 보면 대부분이 인터페이스로 표현되어있다.

- 내부 클래스의 가시성을 제한하고, 인터페이스를 통해 이를 노출하는 코드를 사용한다.
- 결합(coupling)을 줄일 수 있다 : 인터페이스 뒤에 객체를 숨김으로써 실질적인 구현을 추상화하고, 사용자가 추상화된 것에만 의존하게 만들 수 있다.
- 코틀린이 인터페이스를 리턴하는 이유
  - 멀티 플랫폼 언어 : 코틀린/JVM, 코틀린/JS, 코틀린/네이티브에 따라서 구현이 다르다. (최적화)
  - 인터페이스 페이킹(faking) : 클래스 모킹보다 간단하다.
  - 선언과 사용이 분리되어있어, 실제 클래스를 자유롭게 변경가능하다.



### 특수객체 래핑

보편적인 객체(universal object)를 특수한 객체(specialistic object)로 래핑

전 : `id: Int` > 후 : `id: Id`

이후에 발생할 수 있는 변경으로부터 코드를 보호할 수 있게한다.

ID 타입을 쉽게 변경할 수 잇게 클래스를 사용한다



### 추상화의 단점

추상화도 비용이 발생한다.

- 너무 많은 것을 숨기면 결과를 이해하는 것 자체가 어려워진다.
- 추상화가 너무 많으면 코드를 이해하기 어렵다.

단위 테스트와 문서의 예제를 이용하여 추상화가 어떻게 사용하는지 확실히 보여줄 수 있게하자.



### 추상화의 균형

추상화의 스코프가 달라질 수 있는 요소 : 팀의 크기 / 팀의 경험 / 프로젝트의 크기 / 특징 세트 / 도메인 지식

- 많은 개발자가 참여하는 프로젝트는 최대한 모듈과 부분을 분리하는 것이 좋다
- DI 프레임워크를 사용하면, 생성이 얼마나 복잡한지는 신경쓰지 않아도 된다.
- 테스트를하거나, 다른 애플리케이션을 기반으로 애플리케이션을 만든다면 추상화 사용이 좋다.
- 프로젝트가 작고 실험적이라면, 추상화를 하지 않고도 직접 변경해도 괜찮다.




# Chapter8. 데이터 체계화

### 필드 자체 캡슐화 (Self Encapsulate Field)

필드에 직접 접근하던 중 그 필드로의 결합에 문제가 생길 땐 그 필드용 읽기/쓰기 메서드를 작성해서 두 메서드를 통해서만 필드에 접근하게 만들자

- 변수 간접 접근 방식을 사용하면 하위 클래스가 메서드에 해당 정보를 가져오는 방식을 재정의할 수 있으며, 데이터 관리가 더 유연해진다.



### 데이터 값을 객체로 전환 (Replace Data Value with Object)

데이터 항목에 데이터나 기능을 더 추가해야할 때는 데이터 항목을 객체로 만들자.

- 개발 초기 단계에서는 단순 정보를 간단한 데이터 항목으로 표현하는 사안에 대해 결정한다. 개발이 진행되다 보면 그런 간단한 항목이 점점 복잡해진다.



### 값을 참조로 전환 (Change Value to Reference)

클래스에 같은 인스턴스가 많이 들어있어서 이것들을 하나의 객체로 바꿔야 할 땐 그 객체를 참조 객체로 전환하자

- 객체는 참조 객체와 값 객체로 분류할 수 있다.
- 각 객체는 현실에서의 한 객체에 대응하므로, 둘이 같은지 검사할 때는 객체 ID를 사용한다.



### 참조를 값으로 전환 (Change Reference to Value)

참조 객체가 작고 수정할 수 없고 관리하기 힘들 땐 그 참조객체를 값 객체로 만들자

- 참조 객체를 사용한 작업이 복잡해지는 순간이 참조를 값으로 바꿔야 할 시점이다.
- 변경 불가의 뜻 : Money(currency, value)와 같이 변경불가인 값 객체 - 식별자가 없는 객체



### 배열을 객체로 전환 (Replace Array with Object)

배열을 구성하는 특정 원소가 별의별 의미를 지닐 땐 그 배열을 각 원소마다 하나씩 든 객체로 전환하자.

- 배열은 비슷한 객체들의 컬렉션을 일정 순서로 담는 용도로만 사용해야한다. 
- 배열안에 각양각색의 것이 무수히 들어있으면 안된다 : 배열 안의 정보를 표현할 새 클래스를 작성하자.



### 관측 데이터 복제 (Duplicate Observed Data)

도메인 데이터는 GUI 컨트롤 안에서만 사용 가능한데, 도메인 메서드가 그 데이터에 접근해야 할 땐 그 데이터를 도메인 객체로 복사하고, 양측의 데이터를 동기화하는 관측 인터페이스를 observer를 작성하자

- 기능은 간단히 분리할 수 있어도 데이터는 분리하기 어려울 때가 많다.
- 표현 클래스를 도메인 클래스의 관측 인터페이스로 만들자

##### 이벤트 리스너

관측데이터 복제 기법 : 관측 인터페이스 Observer나 관측 클래스 Observable 대신 이벤트 리스너를 사용할 때도 적용된다. 

도메인 객체는 관측 클래스 안에서와 같은 방식으로 리스너를 등록하고, update 메서드 안에서와 같이 변경이 있을 때 리스너에 이벤트를 전송해야한다.



### 클래스의 단방향 연결을 양방향으로 전환 (Change Unidirectional Association to Bidirectional)

두 클래스가 서로의 기능을 사용해야 하는데, 한 방향으로만 연결되어 있을 땐 역 포인터를 추가하고 두 클래스를 모두 업데이트할 수 있게 접근 한정자를 수정하자

- 두 객체가 모두 참조 객체이고 연결이 일대다이면 참조가 하나 들어 있는 객체를 제어 객체로 정한다. : 1:N 이라고 하면 N에 있는 참조를 먼저 변경하고 후에 1에 있는 참조를 변경한다.
- 한 객체가 다른 객체에 포함될 때는 포함하는 객체를 제어 객체로 정한다.
- 두 객체가 모두 참조 객체이고 연결이 다대다이면, 어느 클래스를 연결 제어 객체로 정해도 상관없다.

> 제어 객체 : 최초 접근하는 객체



### 클래스 양방향 연결을 단방향으로 전환 (Change Bidirectional Association to Unidirectional)

두 클래스가 양방향으로 연결되어 있는데 한 클래스가 다른 클래스의 기능을 더 이상 사용하지 않게 됐을 땐 불필요한 방향의 연결을 끊자

- 양방향 연결을 유지하고 객체가 적절히 생성되고 제거되는지 확인하는 복잡함이 더해진다
- 양방향 연결이 많으면 좀비 객체가 발생하기도 쉽다 (참조가 삭제도지 않아 제거되어야 함에도 남아서 떠도는 객체)
- 양방향 연결은 꼭 필요할 때만 사용해야한다.
- 고칠 때는 주로 객체에 하나의 매개변수로 전달하는 방법을 사용할 때가 많다.
- 읽기/쓰기 메서드를 그대로 두면 코드 구현부의 연결은 단방향이지만 인터페이스 안의 연결은 양방향성이 유지된다.



### 마법 숫자를 기호 상수로 전환 (Replace Magic Number with Symbolic Constant)

특수 의미를 지닌 리터럴 숫자가 있을 땐 의미를 살린 이름의 상수를 작성한 후 리터럴 숫자를 그 상수로 교체하자.

- 마법 숫자(magic number)는 전산 업계의 가장 오래된 인습 중 하나다.
- 마법 숫자 : 특수한 값을 갖는 숫자 (여러 곳에서 논리적으로 같은 숫자를 참조해야 할 때 특히 문제가 많다)



### 필드 캡슐화 (Encapsulate Field)

public 필드가 있을 땐 그 필드를 private으로 만들고 필드용 읽기 메서드와 쓰기 메서드를 작성하자

- 캡슐화(데이터 은닉)를 위해 데이터는 절대로 public 타입으로 선언하면 안 된다. > 모르는 다른 객체가 데이터 값을 읽고 변경할 수 있다.



### 컬렉션 캡슐화 (Encapsulate Collection)

메서드가 컬렉션을 반환할 땐 그 메서드가 읽기전용 뷰를 반환하게 수정하고 추가 메서드와 삭제 메서드를 작성하자

- 컬렉션의 읽기 메서드는 컬렉션 객체 자체를 반환해선 안된다. 
- 값이 여러 개인 속성을 읽는 읽기 메서드는 컬렉션 조작이 불가능한 형식을 반환하고 불필요하게 자세한 컬렉션 구조 정보는 감춰야한다.



### 레코드를 데이터 클래스로 전환 (Replace Record with Data Class)

전통적인 프로그래밍 환경에서 레코드 구조를 이용한 인터페이스를 제공해야 할 땐 레코드 구조를 저장할 덤 데이터 객체를 작성하자

- 덤 데이터 객체 : 데이터가 거의 들어 있지 않은 객체



### 분류 부호를 클래스로 전환 (Replace Type Code with Class)

기능에 영향을 미치는 숫자형 분류 부호가 든 클래스가 있을 땐 그 숫자를 새 클래스로 바꾸자.

- 숫자형 분류 부호 (type code) == 열거 타입 (enumeration type)
- 분류 부호를 다른 것으로 전환하는 방안도 고려해야한다. 분류 부호를 클래스로 만드는 건 분류 부호가 순수한 데이터일 때만 실시해야한다.



### 분류 부호를 하위 클래스로 전환 (Replace Type Code with Subclasses)

클래스 기능에 영향을 주는 변경불가 분류 부호가 있을 땐 분류 부호를 하위클래스로 만들자.

- 분류 부호의 값이 객체 생성 후 변할때는 적용할 수 없다.
- 다른 이유로 분류 부호를 이미 하위클래스로 만들었을 때는 적용할 수 없다.
- 분류 부호를 상태/전략 패턴으로 전환을 실시해야 할 때는 적용할 수 없다.



### 분류 부호를 상태/전략 패턴으로 전환 (Replace Type Code with State/Strategy)

분류 부호가 클래스의 기능에 영향을 주지만 그 하위 클래스로 전환할 수 없을 땐 그 분류 부호를 상태 객체로 만들자

- 분류 부호가 객체 수명주기 동안 변할 때나 다른 이유로 하위클래스로 만들 수 없을 때 사용한다
- 상태별 데이터를 이동하고 객체를 변화하는 상태로 생각날 때는 상태 패턴이 더 적절하다



### 하위 클래스를 필드로 전환 (Replace Subclass with Fields)

여러 하위 클래스가 상수 데이터를 반환하는 메서드만 다를 땐 각 하위 클래스의 메서드를 상위클래스 필드로 전환하고 하위클래스는 전부 삭제하자

- 상수 메서드가 유용해도 하위 클래스를 상수 메서드로만 구성한다고 해서 그만큼 효용성이 커지는건 아니다.








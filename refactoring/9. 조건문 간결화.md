# Chapter9. 조건문 간결화

### 조건문 쪼개기 (decompose conditional)

복잡한 조건문(if-then-else)이 있을 땐, if, then, else 부분을 각각 메서드로 빼내자

- 조건이 눈에 잘 들어오고 갈라지는 로직 흐름을 알아보기 쉽다.
- 로직을 왜 그렇게 갈라놨는지도 확실히 알 수 있다.



### 중복 조건식 통합 (Consolidate Conditional Expression)

여러 조건 검사식의 결과가 같을 땐 하나의 조건문으로 합친 후 메서드로 빼내자

- 논리연산자 AND, OR을 이용해서 여러 조건 검사를 하나로 합치자
- 조건식을 합치면 여러 검사를 OR 연산자로 연결해서 실제로 하나의 검사 수행을 표현해서 무엇을 검사하는지 더 확실히 이해할 수 있다.
- 조건식 통합 리팩토링 기법을 실시하면 메서드 추출을 적용할 수 있는 기반이 마련된다.



### 조건문의 공통 실행 코드 빼내기 (Consolidate Duplicate Conditional Fragments)

조건문의 모든 절에 같은 실행 코드가 있을 땐 같은 부분을 조건문 밖으로 빼자

- 각 절이 공통적으로 실행할 기능과 서로 다르게 실행할 기능을 한눈에 알 수 있다.



### 제어 플래그 제거 (RemoveControl Flag)

논리 연산식의 제어 플래그 역할을 하는 변수가 있을 땐 그 변수를 break 문이나 return 문으로 바꾸자

- 제어 플래그의 단점은 코드안의 각종 플래그로 인해 조건문이 복잡해지기 때문이다.
- 제어 플래그 : 조건문을 빠져나갈 시점을 결정하는 것 (break, continue)



### 여러 겹의 조건문을 감시 절로 전환(Replace Nested Conditional with Guard Clauses)

메서드에 조건문이 있어서 정상적인 실행경로를 파악하기 힘들 땐 모든 특수한 경우에 감시절을 사용하자.

- 조건식의 형태 1 : 어느 한 경로가 정상적인 동작의 일부인지 검사하는 형태
- 조건식의 형태 2 : 조건식 판별의 한 결과만 정상적인 동작을 나타내고 나머지는 비정상적인 동작을 나타내는 형태
- 감시 절 : 이것은 드문 경우이니 경우가 발생하면 작업을 수행한 후 빠져나와라



### 조건문을 재정의로 전환 (Replace Conditional with Polymorphism)

객체 타입에 따라 다른 기능을 실행하는 조건문이 있을 땐 조건문의 각 절을 하위클래스의 재정의 메서드 안으로 옮기고 원본 메서드는 abstract 타입으로 수정하자

- switch 방식 : 새 타입을 추가하려면 모든 조건문을 찾아서 수정해야한다
- 하위 클래스 사용 : 새 하위클래스를 작성하고 적당한 메서드를 넣으면 된다. >. 새 클래스로 위임하게 만들 수 있다



### Null 검사를 널객체에 위임 (Introduce Null Object)

null 값을 검사하는 코드가 계속 나올 땐 null 값을 널 객체로 만들자.

- 재정의의 본질 : 어떤 종류인지 객체에 일일이 물어서 그 응답에 따라 실행할 기능을 호출하는 것이 아니라, 묻지도 따지지도 않고 기능을 곧바로 호출하는 것.
- Null 객체 : 조건문에 따라 null일 경우에 리턴하는 값을 널객체에 넣어준다.



### 어설션 넣기 (Introduce Assertion)

일부 코드가 프로그램의 어떤 상태를 전제할 땐 어설션을 넣어서 그 전제를 확실하게 코드로 작성하자

- 특정 조건이 참일때만 코드의 코드의 일부분이 실행이 되는 경우가 있다. 이럴때 어설션을 넣어 명확히 드러내자
- 어설션 : 항상 참으로 전제되는 조건문 : 프로그래미가 오류를 범한 경우 - 어설션이 실패할경우 예외를 통지해야한다.
- 어설션은 의사소통과 디버깅에 도움을 준다
- 어설션은 프로그램 기능에 전혀 영향을 주지 않는다.
- assert 메서드의 매개변수로 전달하는 모든 표현식이 그대로 실행되는 문제가 있다.





### 


# Chapter7. 객체 간의 기능 이동

### 메서드 이동

메서드가 자신이 속한 클래스보다 다른 클래스의 기능을 더 많이 이용할 땐 그 메서드가 제일 많이 이용하는 클래스 안에서 비슷한 내용의 새 메서드를 작성하자. 기존 메서드는 간단한 대리 메서드로 전환하든지 아예 삭제하자.

- 클래스에 기능이 너무 낳거나 클래스가 다른 클래스와 과하게 연동되어 의존성이 지나칠 때
- 그 메서드를 호출하는 메서드, 그 메서드가 호출하는 메서드, 상속 계층에서 그 메서드를 재정의하는 메서드를 살펴본다
- 원본 객체에서 대상 객체를 참조할 때 : 파라미터, 객체



### 필드 이동

어떤 필드가 자신이 속한 클래스보다 다른 클래스에서 더 많이 사용될 때는 대상 클래스 안에 새 필드를 선언하고 그 필드 참조 부분을 전부 새 필드 참조로 수정하자

- 어떤 필드가 자신이 속한 클래스보다 다른 클래스에 잇는 메서드를 더 많이 참조해서 정보를 이용한다면 그 필드를 옮기는걸 생각해보자



### 클래스 추출

두 클래스가 처리해야 할 기능이 하나의 클래스에 들어 있을 땐 새 클래스를 만들고 기존 클래스의 관련 필드와 메서드를 새 클래스로 옮기자

- 클래스는 확실하게 추상화되어야하며, 명확한 기능을 담당해야한다.
- 데이터나 메서드를 하나 제거하면 어떻게 될지, 다른 필드와 메서드를 추가하는 건 합리적이지 않은지 자문해본다.
- 원본 클래스에서 새 클래스로의 링크를 만들자 (양방향 링크를 만ㄷ르어야 할 수도 있는데, 필요할 때까진 역방향 링크를 만들지 말자)
- 새 클래스를 클라이언트에 어느 정도 공개할지도 결정해야한다. 
- 클래스 추출은 두 결과 클래스에 따로 락을 걸 수 있어서 병렬 실행 프로그램의 생동감을 향상시키는 용도로 흔히 사용되는 기법이다



### 클래스 내용 직접 삽입

클래스에 기능이 너무 적을 땐 그 클래스의 모든 기능을 다른 클래스로 합쳐놓고 원래의 클래스는 삭제하자



### 대리 객체 은폐

클라이언트가 객체의 대리 클래스를 호출할 땐 대리 클래스를 감추는 메서드를 서버에 작성하자

- 캡슐화 : 객체가 시스템의 다른 부분에 대한 정보의 일부만 알 수 있게 은폐하는 것
- 대리객체를 감추고 간단한 위임메서드를 서버에 두어서, 해당 위임 메서드는 클라이언트에서 보고 있게해, 서버에서는 대리객체만 변경하면서 클라이언트에 영향이 없게 한다.
- 위임메서드를 작성하게 할 수도 있다.



### 과잉 중개 메서드 제거

클래스에 자잘한 위임이 너무 많을 땐 대리 객체를 클라이언트가 직접 호출하게 하자.

- 대리 객체 은폐를 하면 새 기능을 사용해야 할 때 마다 서버에 간단한 위임 메서드를 추가해야한다.
- 클라이언트가 대리객체를 먼저 거치게끔 수정하면 된다.



### 외래 클래스에 메서드 추가

사용 중인 서버 클래스에 메서드를 추가해야 하는데 그 클래스를 수정할 수 없을 땐 클라이언트 클래스 안에 서버 클래스의 인스턴스를 첫 번째 인자로 받는 메서드를 작성하자.

- 메서드를 여러 번 사용한다면 여기저기에 중복되게 작성 할 수 있는 가능성이 있으므로 이 코드들은 하나의 메서드로 만들어야 한다.
- 가능하면 외래 메서드를 원래 있어야 할 위치로 옮겨 보자



### 국소적 상속확장 클래스 사용

사용 중인 서버 클래스에 여러 개의 메서드를 추가해야 하는데 클래스를 수정할 수 없을 땐 새 클래스를 작성하고 그 안에 필요한 여러 개의 메서드를 작성하자. 이 상속확장 클래스를 원본 클래스의 하위클래스나 래퍼 클래스로 만들자

- 별도의 클래스지만 상속확장하는 클래스의 하위 타입이다. 원본 클래스의 모든 기능도 사용 가능하면서 추가 기능도 들어있다.
- 생성자는 원본 클래스를 인자로 받고. 하위 클래스의 경우 적절한 상위 클래스 생성자를 호출하고, 래퍼 클래스의 경우 대리 필드에 그 인자를 할당한다.
- 래퍼 클래스화 방식을 사용할 때는 원본 클래스를 인자로 받는 메서드들을 처리하는 방법이 문제가 된다.



